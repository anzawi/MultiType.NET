//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by MultiType.NET.SourceGenerator
//     Library Version: 1.0.0.0
//     Runtime Version: 8.0.17
//     Generated: 2025-06-21 20:48:56 UTC
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
namespace MultiType.NET.Core.Anys.Generated;
using global::System.Diagnostics.CodeAnalysis;
using global::System.Diagnostics;
using global::System.Runtime.CompilerServices;
using global::System.Text.Json.Serialization;
using global::MultiType.NET.Core.Helpers;
using global::System.Text.Json;
using global::MultiType.NET.Core.Exceptions;
using global::MultiType.NET.Core.Serialization.Generated;

/// <inheritdoc/>
[JsonConverter(typeof(AnyJsonConverter<,,,,,, >))]
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly struct Any<T1, T2, T3, T4, T5, T6, T7> : global::MultiType.NET.Core.IAny
{
    private string DebuggerDisplay => TypeIndex == 0 ? "[Uninitialized]" : $"[TypeIndex: {TypeIndex}] Value = {Value} ({Value?.GetType().Name})";

    private readonly ValueType? _valueType;
    private readonly object? _referenceType;
    private readonly bool _isValueType;
    /// <inheritdoc/>
    public byte TypeIndex { get; }
    /// <inheritdoc/>
    public object? Value => _isValueType ? _valueType : _referenceType;
    /// <inheritdoc/>
    public Type Type => Value?.GetType() ?? typeof(void);
    /// <inheritdoc/>
    public bool HasValue => this.Value is not null;
    /// <inheritdoc/>
    public bool IsNull => _valueType is null && _referenceType is null;
    /// <summary>
    /// The set of allowed types for this Any.
    /// </summary>
    public static Type[] AllowedTypes => new[]
    {
        typeof(T1),
        typeof(T2),
        typeof(T3),
        typeof(T4),
        typeof(T5),
        typeof(T6),
        typeof(T7)
    };

    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Is<T>() => (typeof(T) == typeof(T1) && TypeIndex == 1) || (typeof(T) == typeof(T2) && TypeIndex == 2) || (typeof(T) == typeof(T3) && TypeIndex == 3) || (typeof(T) == typeof(T4) && TypeIndex == 4) || (typeof(T) == typeof(T5) && TypeIndex == 5) || (typeof(T) == typeof(T6) && TypeIndex == 6) || (typeof(T) == typeof(T7) && TypeIndex == 7);
    /// <inheritdoc/>
    public T As<T>()
    {
        if (Is<T>())
            return (T)Value!;
        throw new InvalidCastException($"Type {typeof(T).Name} is not stored in this Any<{typeof(T1).Name}, {typeof(T2).Name}, {typeof(T3).Name}, {typeof(T4).Name}, {typeof(T5).Name}, {typeof(T6).Name}, {typeof(T7).Name}>.");
    }

    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T? AsNullable<T>()
        where T : class
    {
        if (IsNull)
            return null;
        return As<T>();
    }

    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T? AsNullableStruct<T>()
        where T : struct
    {
        if (IsNull)
            return null;
        return As<T>();
    }

    /// <summary>
    /// Creates a new Any from the given value.
    /// </summary>
    /// <remarks>
    /// ⚠️ <b>Performance Warning:</b>
    /// This method causes boxing of value types. For best performance, use <c>FromTn</c>, or implicit casting instead.
    /// </remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7> From(object? value)
    {
        return value switch
        {
            T1 v1 => new Any<T1, T2, T3, T4, T5, T6, T7>(v1),
            T2 v2 => new Any<T1, T2, T3, T4, T5, T6, T7>(v2),
            T3 v3 => new Any<T1, T2, T3, T4, T5, T6, T7>(v3),
            T4 v4 => new Any<T1, T2, T3, T4, T5, T6, T7>(v4),
            T5 v5 => new Any<T1, T2, T3, T4, T5, T6, T7>(v5),
            T6 v6 => new Any<T1, T2, T3, T4, T5, T6, T7>(v6),
            T7 v7 => new Any<T1, T2, T3, T4, T5, T6, T7>(v7),
            _ => throw new InvalidCastException($"Cannot cast {value?.GetType().Name ?? "null"} to Any of ({typeof(T1).Name}, {typeof(T2).Name}, {typeof(T3).Name}, {typeof(T4).Name}, {typeof(T5).Name}, {typeof(T6).Name}, {typeof(T7).Name})")};
    }

    /// <summary>
    /// Creates a new Any from the given value.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryFrom(object? value, out Any<T1, T2, T3, T4, T5, T6, T7> result)
    {
        switch (value)
        {
            case T1 v1:
                result = new Any<T1, T2, T3, T4, T5, T6, T7>(v1);
                return true;
            case T2 v2:
                result = new Any<T1, T2, T3, T4, T5, T6, T7>(v2);
                return true;
            case T3 v3:
                result = new Any<T1, T2, T3, T4, T5, T6, T7>(v3);
                return true;
            case T4 v4:
                result = new Any<T1, T2, T3, T4, T5, T6, T7>(v4);
                return true;
            case T5 v5:
                result = new Any<T1, T2, T3, T4, T5, T6, T7>(v5);
                return true;
            case T6 v6:
                result = new Any<T1, T2, T3, T4, T5, T6, T7>(v6);
                return true;
            case T7 v7:
                result = new Any<T1, T2, T3, T4, T5, T6, T7>(v7);
                return true;
            default:
                result = default;
                return false;
        }
    }

    /// <summary>
    /// Creates a new Any from the given value of type T1.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7> FromT1(T1? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7>(value);
    }

    /// <summary>
    /// Creates a new Any from the given value of type T2.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7> FromT2(T2? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7>(value);
    }

    /// <summary>
    /// Creates a new Any from the given value of type T3.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7> FromT3(T3? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7>(value);
    }

    /// <summary>
    /// Creates a new Any from the given value of type T4.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7> FromT4(T4? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7>(value);
    }

    /// <summary>
    /// Creates a new Any from the given value of type T5.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7> FromT5(T5? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7>(value);
    }

    /// <summary>
    /// Creates a new Any from the given value of type T6.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7> FromT6(T6? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7>(value);
    }

    /// <summary>
    /// Creates a new Any from the given value of type T7.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7> FromT7(T7? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T1? value)
    {
        TypeIndex = 1;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T2? value)
    {
        TypeIndex = 2;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T3? value)
    {
        TypeIndex = 3;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T4? value)
    {
        TypeIndex = 4;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T5? value)
    {
        TypeIndex = 5;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T6? value)
    {
        TypeIndex = 6;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T7? value)
    {
        TypeIndex = 7;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7>(T1? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7>(T2? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7>(T3? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7>(T4? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7>(T5? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7>(T6? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7>(T7? v) => new(v);
    /// <summary>
    /// Returns a string representation of the current Any value.
    /// </summary>
    public override string ToString()
    {
        if (TypeIndex == 0)
            return "Any[Uninitialized]";
        string typeName = Value?.GetType().Name ?? "null";
        string valueStr = Value?.ToString() ?? "null";
        return $"Any[{typeName}] = {valueStr}";
    }

    public override bool Equals(object? obj)
    {
        // Fast path: Reference equality
        if (ReferenceEquals(this, obj))
            return true;
        // Check exact type (prevent cross-type comparison)
        if (obj is not global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7> other)
            return false;
        // Fast path: Same index and both null
        if (TypeIndex == other.TypeIndex && Value is null && other.Value is null)
            return true;
        // Full equality check
        return TypeIndex == other.TypeIndex && Equals(Value, other.Value);
    }

    public override int GetHashCode()
    {
        // Recommended pattern: HashCode.Combine (C# 8+)
        return HashCode.Combine(TypeIndex, Value);
    }

    public static bool operator ==(global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7> left, global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7> right) => left.Equals(right);
    public static bool operator !=(global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7> left, global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7> right) => !left.Equals(right);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Match<TResult>(Func<T1, TResult> case1, Func<T2, TResult> case2, Func<T3, TResult> case3, Func<T4, TResult> case4, Func<T5, TResult> case5, Func<T6, TResult> case6, Func<T7, TResult> case7)
    {
        return this.TypeIndex switch
        {
            1 => case1((T1)Value!),
            2 => case2((T2)Value!),
            3 => case3((T3)Value!),
            4 => case4((T4)Value!),
            5 => case5((T5)Value!),
            6 => case6((T6)Value!),
            7 => case7((T7)Value!),
            _ => throw new InvalidOperationException("Any is not initialized."),
        };
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Match([MaybeNull] Action<T1> case1, [MaybeNull] Action<T2> case2, [MaybeNull] Action<T3> case3, [MaybeNull] Action<T4> case4, [MaybeNull] Action<T5> case5, [MaybeNull] Action<T6> case6, [MaybeNull] Action<T7> case7)
    {
        switch (this.TypeIndex)
        {
            case 1:
                case1((T1)Value!);
                break;
            case 2:
                case2((T2)Value!);
                break;
            case 3:
                case3((T3)Value!);
                break;
            case 4:
                case4((T4)Value!);
                break;
            case 5:
                case5((T5)Value!);
                break;
            case 6:
                case6((T6)Value!);
                break;
            case 7:
                case7((T7)Value!);
                break;
            default:
                throw new InvalidOperationException("Any is not initialized.");
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult? TryMatch<TResult>(Func<T1, TResult>? case1 = null, Func<T2, TResult>? case2 = null, Func<T3, TResult>? case3 = null, Func<T4, TResult>? case4 = null, Func<T5, TResult>? case5 = null, Func<T6, TResult>? case6 = null, Func<T7, TResult>? case7 = null)
    {
        return this.TypeIndex switch
        {
            1when case1 != null => case1((T1)Value!),
            2when case2 != null => case2((T2)Value!),
            3when case3 != null => case3((T3)Value!),
            4when case4 != null => case4((T4)Value!),
            5when case5 != null => case5((T5)Value!),
            6when case6 != null => case6((T6)Value!),
            7when case7 != null => case7((T7)Value!),
            _ => default,
        };
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TryMatch([MaybeNull] Action<T1>? case1 = null, [MaybeNull] Action<T2>? case2 = null, [MaybeNull] Action<T3>? case3 = null, [MaybeNull] Action<T4>? case4 = null, [MaybeNull] Action<T5>? case5 = null, [MaybeNull] Action<T6>? case6 = null, [MaybeNull] Action<T7>? case7 = null)
    {
        switch (this.TypeIndex)
        {
            case 1when case1 != null:
                case1((T1)Value!);
                break;
            case 2when case2 != null:
                case2((T2)Value!);
                break;
            case 3when case3 != null:
                case3((T3)Value!);
                break;
            case 4when case4 != null:
                case4((T4)Value!);
                break;
            case 5when case5 != null:
                case5((T5)Value!);
                break;
            case 6when case6 != null:
                case6((T6)Value!);
                break;
            case 7when case7 != null:
                case7((T7)Value!);
                break;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T1 GetT1(out global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7> remainder)
    {
        remainder = TypeIndex switch
        {
            2 => global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7>.From((T2)Value!),
            3 => global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7>.From((T3)Value!),
            4 => global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7>.From((T4)Value!),
            5 => global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7>.From((T5)Value!),
            6 => global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7>.From((T6)Value!),
            7 => global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7>.From((T7)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T1));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T1), TypeIndex);
            Guards.ThrowIfTypeMismatch<T1>(TypeIndex, 1, Value, out T1 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T1).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T1 GetT1()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T1));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T1), TypeIndex);
            Guards.ThrowIfTypeMismatch<T1>(TypeIndex, 1, Value, out T1 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T1).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T2 GetT2(out global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7>.From((T1)Value!),
            3 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7>.From((T3)Value!),
            4 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7>.From((T4)Value!),
            5 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7>.From((T5)Value!),
            6 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7>.From((T6)Value!),
            7 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7>.From((T7)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T2));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T2), TypeIndex);
            Guards.ThrowIfTypeMismatch<T2>(TypeIndex, 2, Value, out T2 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T2).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T2 GetT2()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T2));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T2), TypeIndex);
            Guards.ThrowIfTypeMismatch<T2>(TypeIndex, 2, Value, out T2 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T2).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T3 GetT3(out global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7>.From((T1)Value!),
            2 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7>.From((T2)Value!),
            4 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7>.From((T4)Value!),
            5 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7>.From((T5)Value!),
            6 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7>.From((T6)Value!),
            7 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7>.From((T7)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T3));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T3), TypeIndex);
            Guards.ThrowIfTypeMismatch<T3>(TypeIndex, 3, Value, out T3 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T3).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T3 GetT3()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T3));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T3), TypeIndex);
            Guards.ThrowIfTypeMismatch<T3>(TypeIndex, 3, Value, out T3 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T3).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T4 GetT4(out global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7>.From((T1)Value!),
            2 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7>.From((T2)Value!),
            3 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7>.From((T3)Value!),
            5 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7>.From((T5)Value!),
            6 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7>.From((T6)Value!),
            7 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7>.From((T7)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T4));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T4), TypeIndex);
            Guards.ThrowIfTypeMismatch<T4>(TypeIndex, 4, Value, out T4 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T4).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T4 GetT4()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T4));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T4), TypeIndex);
            Guards.ThrowIfTypeMismatch<T4>(TypeIndex, 4, Value, out T4 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T4).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T5 GetT5(out global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7>.From((T1)Value!),
            2 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7>.From((T2)Value!),
            3 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7>.From((T3)Value!),
            4 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7>.From((T4)Value!),
            6 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7>.From((T6)Value!),
            7 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7>.From((T7)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T5));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T5), TypeIndex);
            Guards.ThrowIfTypeMismatch<T5>(TypeIndex, 5, Value, out T5 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T5).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T5 GetT5()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T5));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T5), TypeIndex);
            Guards.ThrowIfTypeMismatch<T5>(TypeIndex, 5, Value, out T5 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T5).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T6 GetT6(out global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7>.From((T1)Value!),
            2 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7>.From((T2)Value!),
            3 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7>.From((T3)Value!),
            4 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7>.From((T4)Value!),
            5 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7>.From((T5)Value!),
            7 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7>.From((T7)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T6));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T6), TypeIndex);
            Guards.ThrowIfTypeMismatch<T6>(TypeIndex, 6, Value, out T6 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T6).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T6 GetT6()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T6));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T6), TypeIndex);
            Guards.ThrowIfTypeMismatch<T6>(TypeIndex, 6, Value, out T6 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T6).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T7 GetT7(out global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6>.From((T1)Value!),
            2 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6>.From((T2)Value!),
            3 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6>.From((T3)Value!),
            4 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6>.From((T4)Value!),
            5 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6>.From((T5)Value!),
            6 => global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6>.From((T6)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T7));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T7), TypeIndex);
            Guards.ThrowIfTypeMismatch<T7>(TypeIndex, 7, Value, out T7 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T7).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T7 GetT7()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T7));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 7);
            Guards.ThrowIfNull(Value, typeof(T7), TypeIndex);
            Guards.ThrowIfTypeMismatch<T7>(TypeIndex, 7, Value, out T7 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T7).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGet<T>([MaybeNull] out T value)
    {
        if (Is<T>())
        {
            value = As<T>();
            return true;
        }

        value = default !;
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT1([MaybeNull] out T1 value, out global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 1 && Value is T1 t1)
        {
            value = t1;
            return true;
        }

        if (TypeIndex == 2 && Value is T2 t2)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T2, T3, T4, T5, T6, T7>.From(t7);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT1([MaybeNull] out T1 value)
    {
        value = default;
        if (TypeIndex == 1 && Value is T1 t1)
        {
            value = t1;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT2([MaybeNull] out T2 value, out global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 2 && Value is T2 t2)
        {
            value = t2;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7>.From(t1);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T3, T4, T5, T6, T7>.From(t7);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT2([MaybeNull] out T2 value)
    {
        value = default;
        if (TypeIndex == 2 && Value is T2 t2)
        {
            value = t2;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT3([MaybeNull] out T3 value, out global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 3 && Value is T3 t3)
        {
            value = t3;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7>.From(t2);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T4, T5, T6, T7>.From(t7);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT3([MaybeNull] out T3 value)
    {
        value = default;
        if (TypeIndex == 3 && Value is T3 t3)
        {
            value = t3;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT4([MaybeNull] out T4 value, out global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 4 && Value is T4 t4)
        {
            value = t4;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7>.From(t3);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T5, T6, T7>.From(t7);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT4([MaybeNull] out T4 value)
    {
        value = default;
        if (TypeIndex == 4 && Value is T4 t4)
        {
            value = t4;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT5([MaybeNull] out T5 value, out global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 5 && Value is T5 t5)
        {
            value = t5;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7>.From(t4);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T6, T7>.From(t7);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT5([MaybeNull] out T5 value)
    {
        value = default;
        if (TypeIndex == 5 && Value is T5 t5)
        {
            value = t5;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT6([MaybeNull] out T6 value, out global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 6 && Value is T6 t6)
        {
            value = t6;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7>.From(t5);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T7>.From(t7);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT6([MaybeNull] out T6 value)
    {
        value = default;
        if (TypeIndex == 6 && Value is T6 t6)
        {
            value = t6;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT7([MaybeNull] out T7 value, out global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 7 && Value is T7 t7)
        {
            value = t7;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6>.From(t6);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT7([MaybeNull] out T7 value)
    {
        value = default;
        if (TypeIndex == 7 && Value is T7 t7)
        {
            value = t7;
            return true;
        }

        return false;
    }

    /// <summary>
    /// Maps the value contained in this Any to a new type using a common result type.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Map<TResult>(Func<T1, TResult> map1, Func<T2, TResult> map2, Func<T3, TResult> map3, Func<T4, TResult> map4, Func<T5, TResult> map5, Func<T6, TResult> map6, Func<T7, TResult> map7)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => map1(v1),
            2when Value is T2 v2 => map2(v2),
            3when Value is T3 v3 => map3(v3),
            4when Value is T4 v4 => map4(v4),
            5when Value is T5 v5 => map5(v5),
            6when Value is T6 v6 => map6(v6),
            7when Value is T7 v7 => map7(v7),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
    }

    /// <summary>
    /// Maps the value to a new Any type with different type parameters.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public global::MultiType.NET.Core.Anys.Generated.Any<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6, TResult7> MapAny<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6, TResult7>(Func<T1, TResult1> map1, Func<T2, TResult2> map2, Func<T3, TResult3> map3, Func<T4, TResult4> map4, Func<T5, TResult5> map5, Func<T6, TResult6> map6, Func<T7, TResult7> map7)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => map1(v1),
            2when Value is T2 v2 => map2(v2),
            3when Value is T3 v3 => map3(v3),
            4when Value is T4 v4 => map4(v4),
            5when Value is T5 v5 => map5(v5),
            6when Value is T6 v6 => map6(v6),
            7when Value is T7 v7 => map7(v7),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
    }

    /// <summary>
    /// Maps the value using different strategies for value types and reference types.
    /// </summary>
    public TResult MapValue<TResult>(Func<ValueType, TResult> valueTypeMapper, Func<object, TResult> referenceTypeMapper)
    {
        if (Value is null)
            throw new InvalidAnyStateException("Cannot map null value");
        return _isValueType ? valueTypeMapper(_valueType!) : referenceTypeMapper(_referenceType!);
    }

    /// <summary>
    /// Asynchronously maps the Any value.
    /// </summary>
    public async Task<TResult> MapAsync<TResult>(Func<T1, Task<TResult>> map1, Func<T2, Task<TResult>> map2, Func<T3, Task<TResult>> map3, Func<T4, Task<TResult>> map4, Func<T5, Task<TResult>> map5, Func<T6, Task<TResult>> map6, Func<T7, Task<TResult>> map7)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => await map1(v1),
            2when Value is T2 v2 => await map2(v2),
            3when Value is T3 v3 => await map3(v3),
            4when Value is T4 v4 => await map4(v4),
            5when Value is T5 v5 => await map5(v5),
            6when Value is T6 v6 => await map6(v6),
            7when Value is T7 v7 => await map7(v7),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
    }

    /// <summary>
    /// Maps the value with null-safety, returning a default value if null.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult MapOrDefault<TResult>(Func<T1, TResult> map1, Func<T2, TResult> map2, Func<T3, TResult> map3, Func<T4, TResult> map4, Func<T5, TResult> map5, Func<T6, TResult> map6, Func<T7, TResult> map7, TResult defaultValue = default !)
    {
        if (IsNull)
            return defaultValue;
        return TypeIndex switch
        {
            1when Value is T1 v1 => map1(v1),
            2when Value is T2 v2 => map2(v2),
            3when Value is T3 v3 => map3(v3),
            4when Value is T4 v4 => map4(v4),
            5when Value is T5 v5 => map5(v5),
            6when Value is T6 v6 => map6(v6),
            7when Value is T7 v7 => map7(v7),
            _ => defaultValue
        };
    }

    /// <summary>
    /// Maps the value with exception handling.
    /// </summary>
    public TResult MapSafe<TResult>(Func<T1, TResult> map1, Func<T2, TResult> map2, Func<T3, TResult> map3, Func<T4, TResult> map4, Func<T5, TResult> map5, Func<T6, TResult> map6, Func<T7, TResult> map7, Func<Exception, TResult> errorHandler)
    {
        try
        {
            return TypeIndex switch
            {
                1when Value is T1 v1 => map1(v1),
                2when Value is T2 v2 => map2(v2),
                3when Value is T3 v3 => map3(v3),
                4when Value is T4 v4 => map4(v4),
                5when Value is T5 v5 => map5(v5),
                6when Value is T6 v6 => map6(v6),
                7when Value is T7 v7 => map7(v7),
                _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
        }
        catch (Exception ex)
        {
            return errorHandler(ex);
        }
    }

    /// <summary>
    /// Maps the value conditionally based on predicates.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult MapWhere<TResult>(Func<T1, bool> predicate1, Func<T1, TResult> map1, Func<T2, bool> predicate2, Func<T2, TResult> map2, Func<T3, bool> predicate3, Func<T3, TResult> map3, Func<T4, bool> predicate4, Func<T4, TResult> map4, Func<T5, bool> predicate5, Func<T5, TResult> map5, Func<T6, bool> predicate6, Func<T6, TResult> map6, Func<T7, bool> predicate7, Func<T7, TResult> map7, TResult defaultValue = default !)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 && predicate1(v1) => map1(v1),
            2when Value is T2 v2 && predicate2(v2) => map2(v2),
            3when Value is T3 v3 && predicate3(v3) => map3(v3),
            4when Value is T4 v4 && predicate4(v4) => map4(v4),
            5when Value is T5 v5 && predicate5(v5) => map5(v5),
            6when Value is T6 v6 && predicate6(v6) => map6(v6),
            7when Value is T7 v7 && predicate7(v7) => map7(v7),
            _ => defaultValue
        };
    }

    /// <summary>
    /// Maps with access to the entire Any instance.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult MapWithContext<TResult>(Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T1, TResult> map1, Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T2, TResult> map2, Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T3, TResult> map3, Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T4, TResult> map4, Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T5, TResult> map5, Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T6, TResult> map6, Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T7, TResult> map7)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => map1(this, v1),
            2when Value is T2 v2 => map2(this, v2),
            3when Value is T3 v3 => map3(this, v3),
            4when Value is T4 v4 => map4(this, v4),
            5when Value is T5 v5 => map5(this, v5),
            6when Value is T6 v6 => map6(this, v6),
            7when Value is T7 v7 => map7(this, v7),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
    }

    /// <summary>
    /// Projects the Any value into a new form using the specified selector functions.
    /// </summary>
    public TResult Select<TResult>(Func<T1, TResult> selector1, Func<T2, TResult> selector2, Func<T3, TResult> selector3, Func<T4, TResult> selector4, Func<T5, TResult> selector5, Func<T6, TResult> selector6, Func<T7, TResult> selector7)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => selector1(v1),
            2when Value is T2 v2 => selector2(v2),
            3when Value is T3 v3 => selector3(v3),
            4when Value is T4 v4 => selector4(v4),
            5when Value is T5 v5 => selector5(v5),
            6when Value is T6 v6 => selector6(v6),
            7when Value is T7 v7 => selector7(v7),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for selection")};
    }

    /// <summary>
    /// Projects the Any value using selector functions, or returns a fallback default.
    /// </summary>
    public TResult SelectOrDefault<TResult>(Func<T1, TResult> selector1, Func<T2, TResult> selector2, Func<T3, TResult> selector3, Func<T4, TResult> selector4, Func<T5, TResult> selector5, Func<T6, TResult> selector6, Func<T7, TResult> selector7, TResult defaultValue = default !)
    {
        try
        {
            return Select(selector1, selector2, selector3, selector4, selector5, selector6, selector7);
        }
        catch
        {
            return defaultValue;
        }
    }

    /// <summary>
    /// Attempts to project the Any value using selector functions.
    /// Returns null if uninitialized or type mismatch.
    /// </summary>
    public TResult? TrySelect<TResult>(Func<T1, TResult> selector1, Func<T2, TResult> selector2, Func<T3, TResult> selector3, Func<T4, TResult> selector4, Func<T5, TResult> selector5, Func<T6, TResult> selector6, Func<T7, TResult> selector7)
    {
        if (TypeIndex == 0 || Value is null)
            return default;
        return Select(selector1, selector2, selector3, selector4, selector5, selector6, selector7);
    }

    /// <summary>
    /// Projects the Any value with access to full context.
    /// </summary>
    public TResult SelectWithContext<TResult>(Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T1, TResult> selector1, Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T2, TResult> selector2, Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T3, TResult> selector3, Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T4, TResult> selector4, Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T5, TResult> selector5, Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T6, TResult> selector6, Func<global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7>, T7, TResult> selector7)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => selector1(this, v1),
            2when Value is T2 v2 => selector2(this, v2),
            3when Value is T3 v3 => selector3(this, v3),
            4when Value is T4 v4 => selector4(this, v4),
            5when Value is T5 v5 => selector5(this, v5),
            6when Value is T6 v6 => selector6(this, v6),
            7when Value is T7 v7 => selector7(this, v7),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for selection")};
    }

    /// <summary>
    /// Conditionally maps Any value if predicate passes, otherwise returns default.
    /// </summary>
    public TResult SelectWhere<TResult>(Func<T1, bool> predicate1, Func<T1, TResult> selector1, Func<T2, bool> predicate2, Func<T2, TResult> selector2, Func<T3, bool> predicate3, Func<T3, TResult> selector3, Func<T4, bool> predicate4, Func<T4, TResult> selector4, Func<T5, bool> predicate5, Func<T5, TResult> selector5, Func<T6, bool> predicate6, Func<T6, TResult> selector6, Func<T7, bool> predicate7, Func<T7, TResult> selector7, TResult defaultValue = default !)
    {
        if (TypeIndex == 1 && Value is T1 v1 && predicate1(v1))
            return selector1(v1);
        else if (TypeIndex == 2 && Value is T2 v2 && predicate2(v2))
            return selector2(v2);
        else if (TypeIndex == 3 && Value is T3 v3 && predicate3(v3))
            return selector3(v3);
        else if (TypeIndex == 4 && Value is T4 v4 && predicate4(v4))
            return selector4(v4);
        else if (TypeIndex == 5 && Value is T5 v5 && predicate5(v5))
            return selector5(v5);
        else if (TypeIndex == 6 && Value is T6 v6 && predicate6(v6))
            return selector6(v6);
        else if (TypeIndex == 7 && Value is T7 v7 && predicate7(v7))
            return selector7(v7);
        else
            return defaultValue;
    }

    /// <summary>
    /// Asynchronously projects the Any value using the specified async selector functions.
    /// </summary>
    public async Task<TResult> SelectAsync<TResult>(Func<T1, Task<TResult>> selector1, Func<T2, Task<TResult>> selector2, Func<T3, Task<TResult>> selector3, Func<T4, Task<TResult>> selector4, Func<T5, Task<TResult>> selector5, Func<T6, Task<TResult>> selector6, Func<T7, Task<TResult>> selector7)
    {
        return await (TypeIndex switch
        {
            1when Value is T1 v1 => selector1(v1),
            2when Value is T2 v2 => selector2(v2),
            3when Value is T3 v3 => selector3(v3),
            4when Value is T4 v4 => selector4(v4),
            5when Value is T5 v5 => selector5(v5),
            6when Value is T6 v6 => selector6(v6),
            7when Value is T7 v7 => selector7(v7),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for selection")});
    }

    /// <summary>
    /// Asynchronously projects the Any value, or returns fallback default.
    /// </summary>
    public async Task<TResult> SelectAsyncOrDefault<TResult>(Func<T1, Task<TResult>> selector1, Func<T2, Task<TResult>> selector2, Func<T3, Task<TResult>> selector3, Func<T4, Task<TResult>> selector4, Func<T5, Task<TResult>> selector5, Func<T6, Task<TResult>> selector6, Func<T7, Task<TResult>> selector7, TResult defaultValue = default !)
    {
        try
        {
            return await SelectAsync(selector1, selector2, selector3, selector4, selector5, selector6, selector7);
        }
        catch
        {
            return defaultValue;
        }
    }

    /// <summary>
    /// Executes the appropriate action based on the Any type.
    /// </summary>
    public void Switch(Action<T1> case1, Action<T2> case2, Action<T3> case3, Action<T4> case4, Action<T5> case5, Action<T6> case6, Action<T7> case7)
    {
        switch (TypeIndex)
        {
            case 1when Value is T1 v1:
                case1(v1);
                break;
            case 2when Value is T2 v2:
                case2(v2);
                break;
            case 3when Value is T3 v3:
                case3(v3);
                break;
            case 4when Value is T4 v4:
                case4(v4);
                break;
            case 5when Value is T5 v5:
                case5(v5);
                break;
            case 6when Value is T6 v6:
                case6(v6);
                break;
            case 7when Value is T7 v7:
                case7(v7);
                break;
            default:
                throw new InvalidAnyStateException("Any is not in a valid state for switching");
        };
    }

    /// <summary>
    /// Asynchronously executes the appropriate action based on the Any type.
    /// </summary>
    public async Task SwitchAsync(Func<T1, Task> case1, Func<T2, Task> case2, Func<T3, Task> case3, Func<T4, Task> case4, Func<T5, Task> case5, Func<T6, Task> case6, Func<T7, Task> case7)
    {
        switch (TypeIndex)
        {
            case 1when Value is T1 v1:
                await case1(v1);
                break;
            case 2when Value is T2 v2:
                await case2(v2);
                break;
            case 3when Value is T3 v3:
                await case3(v3);
                break;
            case 4when Value is T4 v4:
                await case4(v4);
                break;
            case 5when Value is T5 v5:
                await case5(v5);
                break;
            case 6when Value is T6 v6:
                await case6(v6);
                break;
            case 7when Value is T7 v7:
                await case7(v7);
                break;
            default:
                throw new InvalidAnyStateException("Any is not in a valid state for switching");
        }
    }

    /// <summary>
    /// Executes the appropriate action if the Any is initialized; otherwise, runs default fallback.
    /// </summary>
    public void SwitchOrDefault(Action<T1> case1, Action<T2> case2, Action<T3> case3, Action<T4> case4, Action<T5> case5, Action<T6> case6, Action<T7> case7, Action fallback)
    {
        switch (TypeIndex)
        {
            case 1when Value is T1 v1:
                case1(v1);
                break;
            case 2when Value is T2 v2:
                case2(v2);
                break;
            case 3when Value is T3 v3:
                case3(v3);
                break;
            case 4when Value is T4 v4:
                case4(v4);
                break;
            case 5when Value is T5 v5:
                case5(v5);
                break;
            case 6when Value is T6 v6:
                case6(v6);
                break;
            case 7when Value is T7 v7:
                case7(v7);
                break;
            default:
                fallback();
                break;
        }
    }

    /// <summary>
    /// Deconstructs the Any into individual out variables based on the active type.
    /// </summary>
    public void Deconstruct(out T1 value1, out T2 value2, out T3 value3, out T4 value4, out T5 value5, out T6 value6, out T7 value7)
    {
        value1 = default !;
        value2 = default !;
        value3 = default !;
        value4 = default !;
        value5 = default !;
        value6 = default !;
        value7 = default !;
        switch (TypeIndex)
        {
            case 1when Value is T1 v1:
                value1 = v1;
                break;
            case 2when Value is T2 v2:
                value2 = v2;
                break;
            case 3when Value is T3 v3:
                value3 = v3;
                break;
            case 4when Value is T4 v4:
                value4 = v4;
                break;
            case 5when Value is T5 v5:
                value5 = v5;
                break;
            case 6when Value is T6 v6:
                value6 = v6;
                break;
            case 7when Value is T7 v7:
                value7 = v7;
                break;
            default:
                throw new InvalidAnyStateException($"""
                Unable to deconstruct Any — invalid TypeIndex ({TypeIndex}) or type mismatch.
                Actual value: {Value?.GetType().Name ?? "null"}
            """);
        }
    }

    public static bool TryParse(string input, IFormatProvider? _, out global::MultiType.NET.Core.Anys.Generated.Any<T1, T2, T3, T4, T5, T6, T7> result)
    {
        try
        {
            if (TryCast<T1>(input, out var t1))
            {
                result = FromT1(t1);
                return true;
            }

            if (TryCast<T2>(input, out var t2))
            {
                result = FromT2(t2);
                return true;
            }

            if (TryCast<T3>(input, out var t3))
            {
                result = FromT3(t3);
                return true;
            }

            if (TryCast<T4>(input, out var t4))
            {
                result = FromT4(t4);
                return true;
            }

            if (TryCast<T5>(input, out var t5))
            {
                result = FromT5(t5);
                return true;
            }

            if (TryCast<T6>(input, out var t6))
            {
                result = FromT6(t6);
                return true;
            }

            if (TryCast<T7>(input, out var t7))
            {
                result = FromT7(t7);
                return true;
            }
        }
        catch
        {
        // ignore
        }

        result = default;
        return false;
    }

    public static bool TryCast<T>(string? input, out T? value)
    {
        value = default;
        if (typeof(T).IsPrimitiveType(input, out var parsed))
        {
            value = (T)parsed!;
            return true;
        }

        try
        {
            bool needsQuotes = typeof(T) == typeof(string) && (input?.StartsWith("\"") != true && input?.EndsWith("\"") != true);
            string jsonInput = needsQuotes ? $"\"{input}\"" : input!;
            value = JsonSerializer.Deserialize<T>(jsonInput);
            return value is not null;
        }
        catch
        {
            return false;
        }
    }
}