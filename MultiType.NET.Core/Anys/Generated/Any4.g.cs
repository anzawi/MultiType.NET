//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by MultiType.NET.SourceGenerator
//     Library Version: 1.0.0.0
//     Runtime Version: 8.0.7
//     Generated: 2025-06-11 03:45:39 UTC
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
namespace MultiType.NET.Core.Anys.Generated;
using Exceptions;
using Helpers;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text.Json.Serialization;
using MultiType.NET.Core.Serialization.Generated;

/// <inheritdoc/>
[JsonConverter(typeof(AnyJsonConverterFactory))]
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly struct Any<T1, T2, T3, T4> : IAny
{
    private string DebuggerDisplay => TypeIndex == 0 ? "[Uninitialized]" : $"[TypeIndex: {TypeIndex}] Value = {Value} ({Value?.GetType().Name})";

    private readonly ValueType? _valueType;
    private readonly object? _referenceType;
    private readonly bool _isValueType;
    /// <inheritdoc/>
    public byte TypeIndex { get; }
    /// <inheritdoc/>
    public object? Value => _isValueType ? _valueType : _referenceType;
    /// <inheritdoc/>
    public Type Type => Value?.GetType() ?? typeof(void);
    /// <inheritdoc/>
    public bool HasValue => this.Value is not null;
    /// <inheritdoc/>
    public bool IsNull => _valueType is null && _referenceType is null;
    /// <summary>
    /// The set of allowed types for this Any.
    /// </summary>
    public static Type[] AllowedTypes => new[]
    {
        typeof(T1),
        typeof(T2),
        typeof(T3),
        typeof(T4)
    };

    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Is<T>() => Value is T;
    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T As<T>()
    {
        if (typeof(T) == typeof(T1) && TypeIndex == 1 || typeof(T) == typeof(T2) && TypeIndex == 2 || typeof(T) == typeof(T3) && TypeIndex == 3 || typeof(T) == typeof(T4) && TypeIndex == 4)
        {
            return Value is T val ? val : throw new InvalidCastException($"Cannot cast Any value of type {Value?.GetType().Name ?? "null"} to {typeof(T).Name}");
        }

        throw new InvalidCastException($"Type {typeof(T).Name} is not one of the Any type parameters");
    }

    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T? AsNullable<T>()
        where T : class
    {
        if (IsNull)
            return null;
        return As<T>();
    }

    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T? AsNullableStruct<T>()
        where T : struct
    {
        if (IsNull)
            return null;
        return As<T>();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4> From(object? value)
    {
        return value switch
        {
            T1 v1 => new Any<T1, T2, T3, T4>(v1),
            T2 v2 => new Any<T1, T2, T3, T4>(v2),
            T3 v3 => new Any<T1, T2, T3, T4>(v3),
            T4 v4 => new Any<T1, T2, T3, T4>(v4),
            _ => throw new InvalidCastException($"Cannot cast {value?.GetType().Name ?? "null"} to Any of ({typeof(T1).Name}, {typeof(T2).Name}, {typeof(T3).Name}, {typeof(T4).Name})")};
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryFrom(object? value, out Any<T1, T2, T3, T4> result)
    {
        switch (value)
        {
            case T1 v1:
                result = new Any<T1, T2, T3, T4>(v1);
                return true;
            case T2 v2:
                result = new Any<T1, T2, T3, T4>(v2);
                return true;
            case T3 v3:
                result = new Any<T1, T2, T3, T4>(v3);
                return true;
            case T4 v4:
                result = new Any<T1, T2, T3, T4>(v4);
                return true;
            default:
                result = default;
                return false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4> FromT1(T1? value)
    {
        return new Any<T1, T2, T3, T4>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4> FromT2(T2? value)
    {
        return new Any<T1, T2, T3, T4>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4> FromT3(T3? value)
    {
        return new Any<T1, T2, T3, T4>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4> FromT4(T4? value)
    {
        return new Any<T1, T2, T3, T4>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T1? value)
    {
        TypeIndex = 1;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T2? value)
    {
        TypeIndex = 2;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T3? value)
    {
        TypeIndex = 3;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T4? value)
    {
        TypeIndex = 4;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4>(T1? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4>(T2? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4>(T3? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4>(T4? v) => new(v);
    /// <summary>
     // Returns a string representation of the current Any value.
    /// </summary>
    public override string ToString()
    {
        if (TypeIndex == 0)
            return "Any[Uninitialized]";
        string typeName = Value?.GetType().Name ?? "null";
        string valueStr = Value?.ToString() ?? "null";
        return $"Any[{typeName}] = {valueStr}";
    }

    public override bool Equals(object? obj)
    {
        // Fast path: Reference equality
        if (ReferenceEquals(this, obj))
            return true;
        // Check exact type (prevent cross-type comparison)
        if (obj is not Any<T1, T2, T3, T4> other)
            return false;
        // Fast path: Same index and both null
        if (TypeIndex == other.TypeIndex && Value is null && other.Value is null)
            return true;
        // Full equality check
        return TypeIndex == other.TypeIndex && Equals(Value, other.Value);
    }

    public override int GetHashCode()
    {
        // Recommended pattern: HashCode.Combine (C# 8+)
        return HashCode.Combine(TypeIndex, Value);
    }

    public static bool operator ==(Any<T1, T2, T3, T4> left, Any<T1, T2, T3, T4> right) => left.Equals(right);
    public static bool operator !=(Any<T1, T2, T3, T4> left, Any<T1, T2, T3, T4> right) => !left.Equals(right);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Match<TResult>(Func<T1?, TResult> case1, Func<T2?, TResult> case2, Func<T3?, TResult> case3, Func<T4?, TResult> case4)
    {
        return this.TypeIndex switch
        {
            1 => case1(this.Is<T1>() ? this.As<T1>() : default),
            2 => case2(this.Is<T2>() ? this.As<T2>() : default),
            3 => case3(this.Is<T3>() ? this.As<T3>() : default),
            4 => case4(this.Is<T4>() ? this.As<T4>() : default),
            _ => throw new InvalidOperationException("Any is not initialized."),
        };
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Match(Action<T1?> case1, Action<T2?> case2, Action<T3?> case3, Action<T4?> case4)
    {
        switch (this.TypeIndex)
        {
            case 1:
                case1(this.Is<T1>() ? this.As<T1>() : default);
                break;
            case 2:
                case2(this.Is<T2>() ? this.As<T2>() : default);
                break;
            case 3:
                case3(this.Is<T3>() ? this.As<T3>() : default);
                break;
            case 4:
                case4(this.Is<T4>() ? this.As<T4>() : default);
                break;
            default:
                throw new InvalidOperationException("Any is not initialized.");
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult? TryMatch<TResult>(Func<T1?, TResult>? case1 = null, Func<T2?, TResult>? case2 = null, Func<T3?, TResult>? case3 = null, Func<T4?, TResult>? case4 = null)
    {
        return this.TypeIndex switch
        {
            1when case1 != null => case1(this.Is<T1>() ? this.As<T1>() : default),
            2when case2 != null => case2(this.Is<T2>() ? this.As<T2>() : default),
            3when case3 != null => case3(this.Is<T3>() ? this.As<T3>() : default),
            4when case4 != null => case4(this.Is<T4>() ? this.As<T4>() : default),
            _ => default,
        };
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TryMatch(Action<T1?>? case1 = null, Action<T2?>? case2 = null, Action<T3?>? case3 = null, Action<T4?>? case4 = null)
    {
        switch (this.TypeIndex)
        {
            case 1when case1 != null:
                case1(this.Is<T1>() ? this.As<T1>() : default);
                break;
            case 2when case2 != null:
                case2(this.Is<T2>() ? this.As<T2>() : default);
                break;
            case 3when case3 != null:
                case3(this.Is<T3>() ? this.As<T3>() : default);
                break;
            case 4when case4 != null:
                case4(this.Is<T4>() ? this.As<T4>() : default);
                break;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T1 GetT1(out Any<T2, T3, T4> remainder)
    {
        remainder = TypeIndex switch
        {
            2 => Any<T2, T3, T4>.From((T2)Value!),
            3 => Any<T2, T3, T4>.From((T3)Value!),
            4 => Any<T2, T3, T4>.From((T4)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T1));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 4);
            Guards.ThrowIfNull(Value, typeof(T1), TypeIndex);
            Guards.ThrowIfTypeMismatch<T1>(TypeIndex, 1, Value, out T1 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T1).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T1 GetT1()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T1));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 4);
            Guards.ThrowIfNull(Value, typeof(T1), TypeIndex);
            Guards.ThrowIfTypeMismatch<T1>(TypeIndex, 1, Value, out T1 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T1).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T2 GetT2(out Any<T1, T3, T4> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => Any<T1, T3, T4>.From((T1)Value!),
            3 => Any<T1, T3, T4>.From((T3)Value!),
            4 => Any<T1, T3, T4>.From((T4)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T2));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 4);
            Guards.ThrowIfNull(Value, typeof(T2), TypeIndex);
            Guards.ThrowIfTypeMismatch<T2>(TypeIndex, 2, Value, out T2 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T2).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T2 GetT2()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T2));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 4);
            Guards.ThrowIfNull(Value, typeof(T2), TypeIndex);
            Guards.ThrowIfTypeMismatch<T2>(TypeIndex, 2, Value, out T2 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T2).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T3 GetT3(out Any<T1, T2, T4> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => Any<T1, T2, T4>.From((T1)Value!),
            2 => Any<T1, T2, T4>.From((T2)Value!),
            4 => Any<T1, T2, T4>.From((T4)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T3));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 4);
            Guards.ThrowIfNull(Value, typeof(T3), TypeIndex);
            Guards.ThrowIfTypeMismatch<T3>(TypeIndex, 3, Value, out T3 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T3).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T3 GetT3()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T3));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 4);
            Guards.ThrowIfNull(Value, typeof(T3), TypeIndex);
            Guards.ThrowIfTypeMismatch<T3>(TypeIndex, 3, Value, out T3 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T3).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T4 GetT4(out Any<T1, T2, T3> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => Any<T1, T2, T3>.From((T1)Value!),
            2 => Any<T1, T2, T3>.From((T2)Value!),
            3 => Any<T1, T2, T3>.From((T3)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T4));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 4);
            Guards.ThrowIfNull(Value, typeof(T4), TypeIndex);
            Guards.ThrowIfTypeMismatch<T4>(TypeIndex, 4, Value, out T4 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T4).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T4 GetT4()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T4));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 4);
            Guards.ThrowIfNull(Value, typeof(T4), TypeIndex);
            Guards.ThrowIfTypeMismatch<T4>(TypeIndex, 4, Value, out T4 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T4).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT1(out T1? value, out Any<T2, T3, T4> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 1 && Value is T1 t1)
        {
            value = t1;
            return true;
        }

        if (TypeIndex == 2 && Value is T2 t2)
            remainder = Any<T2, T3, T4>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = Any<T2, T3, T4>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = Any<T2, T3, T4>.From(t4);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT1(out T1? value)
    {
        value = default;
        if (TypeIndex == 1 && Value is T1 t1)
        {
            value = t1;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT2(out T2? value, out Any<T1, T3, T4> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 2 && Value is T2 t2)
        {
            value = t2;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = Any<T1, T3, T4>.From(t1);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = Any<T1, T3, T4>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = Any<T1, T3, T4>.From(t4);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT2(out T2? value)
    {
        value = default;
        if (TypeIndex == 2 && Value is T2 t2)
        {
            value = t2;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT3(out T3? value, out Any<T1, T2, T4> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 3 && Value is T3 t3)
        {
            value = t3;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = Any<T1, T2, T4>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = Any<T1, T2, T4>.From(t2);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = Any<T1, T2, T4>.From(t4);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT3(out T3? value)
    {
        value = default;
        if (TypeIndex == 3 && Value is T3 t3)
        {
            value = t3;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT4(out T4? value, out Any<T1, T2, T3> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 4 && Value is T4 t4)
        {
            value = t4;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = Any<T1, T2, T3>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = Any<T1, T2, T3>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = Any<T1, T2, T3>.From(t3);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT4(out T4? value)
    {
        value = default;
        if (TypeIndex == 4 && Value is T4 t4)
        {
            value = t4;
            return true;
        }

        return false;
    }

    /// <summary>
    /// Maps the value contained in this Any to a new type using a common result type.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Map<TResult>(Func<T1, TResult> map1, Func<T2, TResult> map2, Func<T3, TResult> map3, Func<T4, TResult> map4)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => map1(v1),
            2when Value is T2 v2 => map2(v2),
            3when Value is T3 v3 => map3(v3),
            4when Value is T4 v4 => map4(v4),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
    }

    /// <summary>
    /// Maps the value to a new Any type with different type parameters.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Any<TResult1, TResult2, TResult3, TResult4> MapAny<TResult1, TResult2, TResult3, TResult4>(Func<T1, TResult1> map1, Func<T2, TResult2> map2, Func<T3, TResult3> map3, Func<T4, TResult4> map4)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => map1(v1),
            2when Value is T2 v2 => map2(v2),
            3when Value is T3 v3 => map3(v3),
            4when Value is T4 v4 => map4(v4),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
    }

    /// <summary>
    /// Maps the value using different strategies for value types and reference types.
    /// </summary>
    public TResult MapValue<TResult>(Func<ValueType, TResult> valueTypeMapper, Func<object, TResult> referenceTypeMapper)
    {
        if (Value is null)
            throw new InvalidAnyStateException("Cannot map null value");
        return _isValueType ? valueTypeMapper(_valueType!) : referenceTypeMapper(_referenceType!);
    }

    /// <summary>
    /// Asynchronously maps the Any value.
    /// </summary>
    public async Task<TResult> MapAsync<TResult>(Func<T1, Task<TResult>> map1, Func<T2, Task<TResult>> map2, Func<T3, Task<TResult>> map3, Func<T4, Task<TResult>> map4)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => await map1(v1),
            2when Value is T2 v2 => await map2(v2),
            3when Value is T3 v3 => await map3(v3),
            4when Value is T4 v4 => await map4(v4),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
    }

    /// <summary>
    /// Maps the value with null-safety, returning a default value if null.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult MapOrDefault<TResult>(Func<T1, TResult> map1, Func<T2, TResult> map2, Func<T3, TResult> map3, Func<T4, TResult> map4, TResult defaultValue = default !)
    {
        if (IsNull)
            return defaultValue;
        return TypeIndex switch
        {
            1when Value is T1 v1 => map1(v1),
            2when Value is T2 v2 => map2(v2),
            3when Value is T3 v3 => map3(v3),
            4when Value is T4 v4 => map4(v4),
            _ => defaultValue
        };
    }

    /// <summary>
    /// Maps the value with exception handling.
    /// </summary>
    public TResult MapSafe<TResult>(Func<T1, TResult> map1, Func<T2, TResult> map2, Func<T3, TResult> map3, Func<T4, TResult> map4, Func<Exception, TResult> errorHandler)
    {
        try
        {
            return TypeIndex switch
            {
                1when Value is T1 v1 => map1(v1),
                2when Value is T2 v2 => map2(v2),
                3when Value is T3 v3 => map3(v3),
                4when Value is T4 v4 => map4(v4),
                _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
        }
        catch (Exception ex)
        {
            return errorHandler(ex);
        }
    }

    /// <summary>
    /// Maps the value conditionally based on predicates.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult MapWhere<TResult>(Func<T1, bool> predicate1, Func<T1, TResult> map1, Func<T2, bool> predicate2, Func<T2, TResult> map2, Func<T3, bool> predicate3, Func<T3, TResult> map3, Func<T4, bool> predicate4, Func<T4, TResult> map4, TResult defaultValue = default !)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 && predicate1(v1) => map1(v1),
            2when Value is T2 v2 && predicate2(v2) => map2(v2),
            3when Value is T3 v3 && predicate3(v3) => map3(v3),
            4when Value is T4 v4 && predicate4(v4) => map4(v4),
            _ => defaultValue
        };
    }

    /// <summary>
    /// Maps with access to the entire Any instance.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult MapWithContext<TResult>(Func<Any<T1, T2, T3, T4>, T1, TResult> map1, Func<Any<T1, T2, T3, T4>, T2, TResult> map2, Func<Any<T1, T2, T3, T4>, T3, TResult> map3, Func<Any<T1, T2, T3, T4>, T4, TResult> map4)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => map1(this, v1),
            2when Value is T2 v2 => map2(this, v2),
            3when Value is T3 v3 => map3(this, v3),
            4when Value is T4 v4 => map4(this, v4),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
    }

    /// <summary>
    /// Projects the Any value into a new form using the specified selector functions.
    /// </summary>
    public TResult Select<TResult>(Func<T1, TResult> selector1, Func<T2, TResult> selector2, Func<T3, TResult> selector3, Func<T4, TResult> selector4)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => selector1(v1),
            2when Value is T2 v2 => selector2(v2),
            3when Value is T3 v3 => selector3(v3),
            4when Value is T4 v4 => selector4(v4),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for selection")};
    }

    /// <summary>
    /// Projects the Any value using selector functions, or returns a fallback default.
    /// </summary>
    public TResult SelectOrDefault<TResult>(Func<T1, TResult> selector1, Func<T2, TResult> selector2, Func<T3, TResult> selector3, Func<T4, TResult> selector4, TResult defaultValue = default !)
    {
        try
        {
            return Select(selector1, selector2, selector3, selector4);
        }
        catch
        {
            return defaultValue;
        }
    }

    /// <summary>
    /// Attempts to project the Any value using selector functions.
    /// Returns null if uninitialized or type mismatch.
    /// </summary>
    public TResult? TrySelect<TResult>(Func<T1, TResult> selector1, Func<T2, TResult> selector2, Func<T3, TResult> selector3, Func<T4, TResult> selector4)
    {
        if (TypeIndex == 0 || Value is null)
            return default;
        return Select(selector1, selector2, selector3, selector4);
    }

    /// <summary>
    /// Projects the Any value with access to full context.
    /// </summary>
    public TResult SelectWithContext<TResult>(Func<Any<T1, T2, T3, T4>, T1, TResult> selector1, Func<Any<T1, T2, T3, T4>, T2, TResult> selector2, Func<Any<T1, T2, T3, T4>, T3, TResult> selector3, Func<Any<T1, T2, T3, T4>, T4, TResult> selector4)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => selector1(this, v1),
            2when Value is T2 v2 => selector2(this, v2),
            3when Value is T3 v3 => selector3(this, v3),
            4when Value is T4 v4 => selector4(this, v4),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for selection")};
    }

    /// <summary>
    /// Conditionally maps Any value if predicate passes, otherwise returns default.
    /// </summary>
    public TResult SelectWhere<TResult>(Func<T1, bool> predicate1, Func<T1, TResult> selector1, Func<T2, bool> predicate2, Func<T2, TResult> selector2, Func<T3, bool> predicate3, Func<T3, TResult> selector3, Func<T4, bool> predicate4, Func<T4, TResult> selector4, TResult defaultValue = default !)
    {
        if (TypeIndex == 1 && Value is T1 v1 && predicate1(v1))
            return selector1(v1);
        else if (TypeIndex == 2 && Value is T2 v2 && predicate2(v2))
            return selector2(v2);
        else if (TypeIndex == 3 && Value is T3 v3 && predicate3(v3))
            return selector3(v3);
        else if (TypeIndex == 4 && Value is T4 v4 && predicate4(v4))
            return selector4(v4);
        else
            return defaultValue;
    }

    /// <summary>
    /// Asynchronously projects the Any value using the specified async selector functions.
    /// </summary>
    public async Task<TResult> SelectAsync<TResult>(Func<T1, Task<TResult>> selector1, Func<T2, Task<TResult>> selector2, Func<T3, Task<TResult>> selector3, Func<T4, Task<TResult>> selector4)
    {
        return await (TypeIndex switch
        {
            1when Value is T1 v1 => selector1(v1),
            2when Value is T2 v2 => selector2(v2),
            3when Value is T3 v3 => selector3(v3),
            4when Value is T4 v4 => selector4(v4),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for selection")});
    }

    /// <summary>
    /// Asynchronously projects the Any value, or returns fallback default.
    /// </summary>
    public async Task<TResult> SelectAsyncOrDefault<TResult>(Func<T1, Task<TResult>> selector1, Func<T2, Task<TResult>> selector2, Func<T3, Task<TResult>> selector3, Func<T4, Task<TResult>> selector4, TResult defaultValue = default !)
    {
        try
        {
            return await SelectAsync(selector1, selector2, selector3, selector4);
        }
        catch
        {
            return defaultValue;
        }
    }

    /// <summary>
    /// Executes the appropriate action based on the Any type.
    /// </summary>
    public void Switch(Action<T1> case1, Action<T2> case2, Action<T3> case3, Action<T4> case4)
    {
        switch (TypeIndex)
        {
            case 1when Value is T1 v1:
                case1(v1);
                break;
            case 2when Value is T2 v2:
                case2(v2);
                break;
            case 3when Value is T3 v3:
                case3(v3);
                break;
            case 4when Value is T4 v4:
                case4(v4);
                break;
            default:
                throw new InvalidAnyStateException("Any is not in a valid state for switching");
        };
    }

    /// <summary>
    /// Asynchronously executes the appropriate action based on the Any type.
    /// </summary>
    public async Task SwitchAsync(Func<T1, Task> case1, Func<T2, Task> case2, Func<T3, Task> case3, Func<T4, Task> case4)
    {
        switch (TypeIndex)
        {
            case 1when Value is T1 v1:
                await case1(v1);
                break;
            case 2when Value is T2 v2:
                await case2(v2);
                break;
            case 3when Value is T3 v3:
                await case3(v3);
                break;
            case 4when Value is T4 v4:
                await case4(v4);
                break;
            default:
                throw new InvalidAnyStateException("Any is not in a valid state for switching");
        }
    }

    /// <summary>
    /// Executes the appropriate action if the Any is initialized; otherwise, runs default fallback.
    /// </summary>
    public void SwitchOrDefault(Action<T1> case1, Action<T2> case2, Action<T3> case3, Action<T4> case4, Action fallback)
    {
        switch (TypeIndex)
        {
            case 1when Value is T1 v1:
                case1(v1);
                break;
            case 2when Value is T2 v2:
                case2(v2);
                break;
            case 3when Value is T3 v3:
                case3(v3);
                break;
            case 4when Value is T4 v4:
                case4(v4);
                break;
            default:
                fallback();
                break;
        }
    }

    /// <summary>
    /// Deconstructs the Any into individual out variables based on the active type.
    /// </summary>
    public void Deconstruct(out T1 value1, out T2 value2, out T3 value3, out T4 value4)
    {
        value1 = default !;
        value2 = default !;
        value3 = default !;
        value4 = default !;
        switch (TypeIndex)
        {
            case 1when Value is T1 v1:
                value1 = v1;
                break;
            case 2when Value is T2 v2:
                value2 = v2;
                break;
            case 3when Value is T3 v3:
                value3 = v3;
                break;
            case 4when Value is T4 v4:
                value4 = v4;
                break;
            default:
                throw new InvalidAnyStateException($"""
                Unable to deconstruct Any — invalid TypeIndex ({TypeIndex}) or type mismatch.
                Actual value: {Value?.GetType().Name ?? "null"}
            """);
        }
    }
}