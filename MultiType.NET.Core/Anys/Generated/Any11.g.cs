//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by MultiType.NET.SourceGenerator
//     Library Version: 1.0.0.0
//     Runtime Version: 8.0.7
//     Generated: 2025-06-11 03:45:39 UTC
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
namespace MultiType.NET.Core.Anys.Generated;
using Exceptions;
using Helpers;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text.Json.Serialization;
using MultiType.NET.Core.Serialization.Generated;

/// <inheritdoc/>
[JsonConverter(typeof(AnyJsonConverterFactory))]
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly struct Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> : IAny
{
    private string DebuggerDisplay => TypeIndex == 0 ? "[Uninitialized]" : $"[TypeIndex: {TypeIndex}] Value = {Value} ({Value?.GetType().Name})";

    private readonly ValueType? _valueType;
    private readonly object? _referenceType;
    private readonly bool _isValueType;
    /// <inheritdoc/>
    public byte TypeIndex { get; }
    /// <inheritdoc/>
    public object? Value => _isValueType ? _valueType : _referenceType;
    /// <inheritdoc/>
    public Type Type => Value?.GetType() ?? typeof(void);
    /// <inheritdoc/>
    public bool HasValue => this.Value is not null;
    /// <inheritdoc/>
    public bool IsNull => _valueType is null && _referenceType is null;
    /// <summary>
    /// The set of allowed types for this Any.
    /// </summary>
    public static Type[] AllowedTypes => new[]
    {
        typeof(T1),
        typeof(T2),
        typeof(T3),
        typeof(T4),
        typeof(T5),
        typeof(T6),
        typeof(T7),
        typeof(T8),
        typeof(T9),
        typeof(T10),
        typeof(T11)
    };

    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Is<T>() => Value is T;
    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T As<T>()
    {
        if (typeof(T) == typeof(T1) && TypeIndex == 1 || typeof(T) == typeof(T2) && TypeIndex == 2 || typeof(T) == typeof(T3) && TypeIndex == 3 || typeof(T) == typeof(T4) && TypeIndex == 4 || typeof(T) == typeof(T5) && TypeIndex == 5 || typeof(T) == typeof(T6) && TypeIndex == 6 || typeof(T) == typeof(T7) && TypeIndex == 7 || typeof(T) == typeof(T8) && TypeIndex == 8 || typeof(T) == typeof(T9) && TypeIndex == 9 || typeof(T) == typeof(T10) && TypeIndex == 10 || typeof(T) == typeof(T11) && TypeIndex == 11)
        {
            return Value is T val ? val : throw new InvalidCastException($"Cannot cast Any value of type {Value?.GetType().Name ?? "null"} to {typeof(T).Name}");
        }

        throw new InvalidCastException($"Type {typeof(T).Name} is not one of the Any type parameters");
    }

    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T? AsNullable<T>()
        where T : class
    {
        if (IsNull)
            return null;
        return As<T>();
    }

    /// <inheritdoc/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T? AsNullableStruct<T>()
        where T : struct
    {
        if (IsNull)
            return null;
        return As<T>();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> From(object? value)
    {
        return value switch
        {
            T1 v1 => new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v1),
            T2 v2 => new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v2),
            T3 v3 => new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v3),
            T4 v4 => new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v4),
            T5 v5 => new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v5),
            T6 v6 => new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v6),
            T7 v7 => new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v7),
            T8 v8 => new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v8),
            T9 v9 => new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v9),
            T10 v10 => new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v10),
            T11 v11 => new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v11),
            _ => throw new InvalidCastException($"Cannot cast {value?.GetType().Name ?? "null"} to Any of ({typeof(T1).Name}, {typeof(T2).Name}, {typeof(T3).Name}, {typeof(T4).Name}, {typeof(T5).Name}, {typeof(T6).Name}, {typeof(T7).Name}, {typeof(T8).Name}, {typeof(T9).Name}, {typeof(T10).Name}, {typeof(T11).Name})")};
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryFrom(object? value, out Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> result)
    {
        switch (value)
        {
            case T1 v1:
                result = new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v1);
                return true;
            case T2 v2:
                result = new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v2);
                return true;
            case T3 v3:
                result = new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v3);
                return true;
            case T4 v4:
                result = new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v4);
                return true;
            case T5 v5:
                result = new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v5);
                return true;
            case T6 v6:
                result = new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v6);
                return true;
            case T7 v7:
                result = new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v7);
                return true;
            case T8 v8:
                result = new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v8);
                return true;
            case T9 v9:
                result = new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v9);
                return true;
            case T10 v10:
                result = new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v10);
                return true;
            case T11 v11:
                result = new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(v11);
                return true;
            default:
                result = default;
                return false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> FromT1(T1? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> FromT2(T2? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> FromT3(T3? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> FromT4(T4? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> FromT5(T5? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> FromT6(T6? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> FromT7(T7? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> FromT8(T8? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> FromT9(T9? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> FromT10(T10? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> FromT11(T11? value)
    {
        return new Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T1? value)
    {
        TypeIndex = 1;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T2? value)
    {
        TypeIndex = 2;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T3? value)
    {
        TypeIndex = 3;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T4? value)
    {
        TypeIndex = 4;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T5? value)
    {
        TypeIndex = 5;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T6? value)
    {
        TypeIndex = 6;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T7? value)
    {
        TypeIndex = 7;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T8? value)
    {
        TypeIndex = 8;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T9? value)
    {
        TypeIndex = 9;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T10? value)
    {
        TypeIndex = 10;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private Any(T11? value)
    {
        TypeIndex = 11;
        if (value is null)
        {
            _valueType = null;
            _referenceType = null;
            _isValueType = false;
            return;
        }

        if (value is ValueType vt)
        {
            _valueType = vt;
            _referenceType = null;
            _isValueType = true;
        }
        else
        {
            _valueType = null;
            _referenceType = value;
            _isValueType = false;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T1? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T2? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T3? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T4? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T5? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T6? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T7? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T8? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T9? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T10? v) => new(v);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T11? v) => new(v);
    /// <summary>
     // Returns a string representation of the current Any value.
    /// </summary>
    public override string ToString()
    {
        if (TypeIndex == 0)
            return "Any[Uninitialized]";
        string typeName = Value?.GetType().Name ?? "null";
        string valueStr = Value?.ToString() ?? "null";
        return $"Any[{typeName}] = {valueStr}";
    }

    public override bool Equals(object? obj)
    {
        // Fast path: Reference equality
        if (ReferenceEquals(this, obj))
            return true;
        // Check exact type (prevent cross-type comparison)
        if (obj is not Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> other)
            return false;
        // Fast path: Same index and both null
        if (TypeIndex == other.TypeIndex && Value is null && other.Value is null)
            return true;
        // Full equality check
        return TypeIndex == other.TypeIndex && Equals(Value, other.Value);
    }

    public override int GetHashCode()
    {
        // Recommended pattern: HashCode.Combine (C# 8+)
        return HashCode.Combine(TypeIndex, Value);
    }

    public static bool operator ==(Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> left, Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> right) => left.Equals(right);
    public static bool operator !=(Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> left, Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> right) => !left.Equals(right);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Match<TResult>(Func<T1?, TResult> case1, Func<T2?, TResult> case2, Func<T3?, TResult> case3, Func<T4?, TResult> case4, Func<T5?, TResult> case5, Func<T6?, TResult> case6, Func<T7?, TResult> case7, Func<T8?, TResult> case8, Func<T9?, TResult> case9, Func<T10?, TResult> case10, Func<T11?, TResult> case11)
    {
        return this.TypeIndex switch
        {
            1 => case1(this.Is<T1>() ? this.As<T1>() : default),
            2 => case2(this.Is<T2>() ? this.As<T2>() : default),
            3 => case3(this.Is<T3>() ? this.As<T3>() : default),
            4 => case4(this.Is<T4>() ? this.As<T4>() : default),
            5 => case5(this.Is<T5>() ? this.As<T5>() : default),
            6 => case6(this.Is<T6>() ? this.As<T6>() : default),
            7 => case7(this.Is<T7>() ? this.As<T7>() : default),
            8 => case8(this.Is<T8>() ? this.As<T8>() : default),
            9 => case9(this.Is<T9>() ? this.As<T9>() : default),
            10 => case10(this.Is<T10>() ? this.As<T10>() : default),
            11 => case11(this.Is<T11>() ? this.As<T11>() : default),
            _ => throw new InvalidOperationException("Any is not initialized."),
        };
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Match(Action<T1?> case1, Action<T2?> case2, Action<T3?> case3, Action<T4?> case4, Action<T5?> case5, Action<T6?> case6, Action<T7?> case7, Action<T8?> case8, Action<T9?> case9, Action<T10?> case10, Action<T11?> case11)
    {
        switch (this.TypeIndex)
        {
            case 1:
                case1(this.Is<T1>() ? this.As<T1>() : default);
                break;
            case 2:
                case2(this.Is<T2>() ? this.As<T2>() : default);
                break;
            case 3:
                case3(this.Is<T3>() ? this.As<T3>() : default);
                break;
            case 4:
                case4(this.Is<T4>() ? this.As<T4>() : default);
                break;
            case 5:
                case5(this.Is<T5>() ? this.As<T5>() : default);
                break;
            case 6:
                case6(this.Is<T6>() ? this.As<T6>() : default);
                break;
            case 7:
                case7(this.Is<T7>() ? this.As<T7>() : default);
                break;
            case 8:
                case8(this.Is<T8>() ? this.As<T8>() : default);
                break;
            case 9:
                case9(this.Is<T9>() ? this.As<T9>() : default);
                break;
            case 10:
                case10(this.Is<T10>() ? this.As<T10>() : default);
                break;
            case 11:
                case11(this.Is<T11>() ? this.As<T11>() : default);
                break;
            default:
                throw new InvalidOperationException("Any is not initialized.");
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult? TryMatch<TResult>(Func<T1?, TResult>? case1 = null, Func<T2?, TResult>? case2 = null, Func<T3?, TResult>? case3 = null, Func<T4?, TResult>? case4 = null, Func<T5?, TResult>? case5 = null, Func<T6?, TResult>? case6 = null, Func<T7?, TResult>? case7 = null, Func<T8?, TResult>? case8 = null, Func<T9?, TResult>? case9 = null, Func<T10?, TResult>? case10 = null, Func<T11?, TResult>? case11 = null)
    {
        return this.TypeIndex switch
        {
            1when case1 != null => case1(this.Is<T1>() ? this.As<T1>() : default),
            2when case2 != null => case2(this.Is<T2>() ? this.As<T2>() : default),
            3when case3 != null => case3(this.Is<T3>() ? this.As<T3>() : default),
            4when case4 != null => case4(this.Is<T4>() ? this.As<T4>() : default),
            5when case5 != null => case5(this.Is<T5>() ? this.As<T5>() : default),
            6when case6 != null => case6(this.Is<T6>() ? this.As<T6>() : default),
            7when case7 != null => case7(this.Is<T7>() ? this.As<T7>() : default),
            8when case8 != null => case8(this.Is<T8>() ? this.As<T8>() : default),
            9when case9 != null => case9(this.Is<T9>() ? this.As<T9>() : default),
            10when case10 != null => case10(this.Is<T10>() ? this.As<T10>() : default),
            11when case11 != null => case11(this.Is<T11>() ? this.As<T11>() : default),
            _ => default,
        };
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void TryMatch(Action<T1?>? case1 = null, Action<T2?>? case2 = null, Action<T3?>? case3 = null, Action<T4?>? case4 = null, Action<T5?>? case5 = null, Action<T6?>? case6 = null, Action<T7?>? case7 = null, Action<T8?>? case8 = null, Action<T9?>? case9 = null, Action<T10?>? case10 = null, Action<T11?>? case11 = null)
    {
        switch (this.TypeIndex)
        {
            case 1when case1 != null:
                case1(this.Is<T1>() ? this.As<T1>() : default);
                break;
            case 2when case2 != null:
                case2(this.Is<T2>() ? this.As<T2>() : default);
                break;
            case 3when case3 != null:
                case3(this.Is<T3>() ? this.As<T3>() : default);
                break;
            case 4when case4 != null:
                case4(this.Is<T4>() ? this.As<T4>() : default);
                break;
            case 5when case5 != null:
                case5(this.Is<T5>() ? this.As<T5>() : default);
                break;
            case 6when case6 != null:
                case6(this.Is<T6>() ? this.As<T6>() : default);
                break;
            case 7when case7 != null:
                case7(this.Is<T7>() ? this.As<T7>() : default);
                break;
            case 8when case8 != null:
                case8(this.Is<T8>() ? this.As<T8>() : default);
                break;
            case 9when case9 != null:
                case9(this.Is<T9>() ? this.As<T9>() : default);
                break;
            case 10when case10 != null:
                case10(this.Is<T10>() ? this.As<T10>() : default);
                break;
            case 11when case11 != null:
                case11(this.Is<T11>() ? this.As<T11>() : default);
                break;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T1 GetT1(out Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> remainder)
    {
        remainder = TypeIndex switch
        {
            2 => Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T2)Value!),
            3 => Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T3)Value!),
            4 => Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T4)Value!),
            5 => Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T5)Value!),
            6 => Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T6)Value!),
            7 => Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T7)Value!),
            8 => Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T8)Value!),
            9 => Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T9)Value!),
            10 => Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T10)Value!),
            11 => Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T11)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T1));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T1), TypeIndex);
            Guards.ThrowIfTypeMismatch<T1>(TypeIndex, 1, Value, out T1 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T1).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T1 GetT1()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T1));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T1), TypeIndex);
            Guards.ThrowIfTypeMismatch<T1>(TypeIndex, 1, Value, out T1 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T1).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T2 GetT2(out Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T1)Value!),
            3 => Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T3)Value!),
            4 => Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T4)Value!),
            5 => Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T5)Value!),
            6 => Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T6)Value!),
            7 => Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T7)Value!),
            8 => Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T8)Value!),
            9 => Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T9)Value!),
            10 => Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T10)Value!),
            11 => Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From((T11)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T2));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T2), TypeIndex);
            Guards.ThrowIfTypeMismatch<T2>(TypeIndex, 2, Value, out T2 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T2).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T2 GetT2()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T2));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T2), TypeIndex);
            Guards.ThrowIfTypeMismatch<T2>(TypeIndex, 2, Value, out T2 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T2).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T3 GetT3(out Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From((T1)Value!),
            2 => Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From((T2)Value!),
            4 => Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From((T4)Value!),
            5 => Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From((T5)Value!),
            6 => Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From((T6)Value!),
            7 => Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From((T7)Value!),
            8 => Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From((T8)Value!),
            9 => Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From((T9)Value!),
            10 => Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From((T10)Value!),
            11 => Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From((T11)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T3));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T3), TypeIndex);
            Guards.ThrowIfTypeMismatch<T3>(TypeIndex, 3, Value, out T3 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T3).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T3 GetT3()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T3));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T3), TypeIndex);
            Guards.ThrowIfTypeMismatch<T3>(TypeIndex, 3, Value, out T3 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T3).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T4 GetT4(out Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From((T1)Value!),
            2 => Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From((T2)Value!),
            3 => Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From((T3)Value!),
            5 => Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From((T5)Value!),
            6 => Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From((T6)Value!),
            7 => Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From((T7)Value!),
            8 => Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From((T8)Value!),
            9 => Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From((T9)Value!),
            10 => Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From((T10)Value!),
            11 => Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From((T11)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T4));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T4), TypeIndex);
            Guards.ThrowIfTypeMismatch<T4>(TypeIndex, 4, Value, out T4 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T4).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T4 GetT4()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T4));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T4), TypeIndex);
            Guards.ThrowIfTypeMismatch<T4>(TypeIndex, 4, Value, out T4 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T4).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T5 GetT5(out Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From((T1)Value!),
            2 => Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From((T2)Value!),
            3 => Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From((T3)Value!),
            4 => Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From((T4)Value!),
            6 => Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From((T6)Value!),
            7 => Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From((T7)Value!),
            8 => Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From((T8)Value!),
            9 => Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From((T9)Value!),
            10 => Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From((T10)Value!),
            11 => Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From((T11)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T5));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T5), TypeIndex);
            Guards.ThrowIfTypeMismatch<T5>(TypeIndex, 5, Value, out T5 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T5).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T5 GetT5()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T5));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T5), TypeIndex);
            Guards.ThrowIfTypeMismatch<T5>(TypeIndex, 5, Value, out T5 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T5).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T6 GetT6(out Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From((T1)Value!),
            2 => Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From((T2)Value!),
            3 => Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From((T3)Value!),
            4 => Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From((T4)Value!),
            5 => Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From((T5)Value!),
            7 => Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From((T7)Value!),
            8 => Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From((T8)Value!),
            9 => Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From((T9)Value!),
            10 => Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From((T10)Value!),
            11 => Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From((T11)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T6));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T6), TypeIndex);
            Guards.ThrowIfTypeMismatch<T6>(TypeIndex, 6, Value, out T6 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T6).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T6 GetT6()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T6));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T6), TypeIndex);
            Guards.ThrowIfTypeMismatch<T6>(TypeIndex, 6, Value, out T6 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T6).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T7 GetT7(out Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From((T1)Value!),
            2 => Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From((T2)Value!),
            3 => Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From((T3)Value!),
            4 => Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From((T4)Value!),
            5 => Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From((T5)Value!),
            6 => Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From((T6)Value!),
            8 => Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From((T8)Value!),
            9 => Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From((T9)Value!),
            10 => Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From((T10)Value!),
            11 => Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From((T11)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T7));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T7), TypeIndex);
            Guards.ThrowIfTypeMismatch<T7>(TypeIndex, 7, Value, out T7 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T7).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T7 GetT7()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T7));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T7), TypeIndex);
            Guards.ThrowIfTypeMismatch<T7>(TypeIndex, 7, Value, out T7 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T7).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T8 GetT8(out Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From((T1)Value!),
            2 => Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From((T2)Value!),
            3 => Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From((T3)Value!),
            4 => Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From((T4)Value!),
            5 => Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From((T5)Value!),
            6 => Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From((T6)Value!),
            7 => Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From((T7)Value!),
            9 => Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From((T9)Value!),
            10 => Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From((T10)Value!),
            11 => Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From((T11)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T8));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T8), TypeIndex);
            Guards.ThrowIfTypeMismatch<T8>(TypeIndex, 8, Value, out T8 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T8).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T8 GetT8()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T8));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T8), TypeIndex);
            Guards.ThrowIfTypeMismatch<T8>(TypeIndex, 8, Value, out T8 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T8).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T9 GetT9(out Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From((T1)Value!),
            2 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From((T2)Value!),
            3 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From((T3)Value!),
            4 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From((T4)Value!),
            5 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From((T5)Value!),
            6 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From((T6)Value!),
            7 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From((T7)Value!),
            8 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From((T8)Value!),
            10 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From((T10)Value!),
            11 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From((T11)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T9));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T9), TypeIndex);
            Guards.ThrowIfTypeMismatch<T9>(TypeIndex, 9, Value, out T9 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T9).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T9 GetT9()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T9));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T9), TypeIndex);
            Guards.ThrowIfTypeMismatch<T9>(TypeIndex, 9, Value, out T9 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T9).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T10 GetT10(out Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From((T1)Value!),
            2 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From((T2)Value!),
            3 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From((T3)Value!),
            4 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From((T4)Value!),
            5 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From((T5)Value!),
            6 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From((T6)Value!),
            7 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From((T7)Value!),
            8 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From((T8)Value!),
            9 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From((T9)Value!),
            11 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From((T11)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T10));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T10), TypeIndex);
            Guards.ThrowIfTypeMismatch<T10>(TypeIndex, 10, Value, out T10 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T10).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T10 GetT10()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T10));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T10), TypeIndex);
            Guards.ThrowIfTypeMismatch<T10>(TypeIndex, 10, Value, out T10 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T10).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T11 GetT11(out Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> remainder)
    {
        remainder = TypeIndex switch
        {
            1 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From((T1)Value!),
            2 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From((T2)Value!),
            3 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From((T3)Value!),
            4 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From((T4)Value!),
            5 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From((T5)Value!),
            6 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From((T6)Value!),
            7 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From((T7)Value!),
            8 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From((T8)Value!),
            9 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From((T9)Value!),
            10 => Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From((T10)Value!),
            _ => default
        };
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T11));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T11), TypeIndex);
            Guards.ThrowIfTypeMismatch<T11>(TypeIndex, 11, Value, out T11 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T11).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T11 GetT11()
    {
        try
        {
            Guards.ThrowIfNotInitialized(TypeIndex, typeof(T11));
            Guards.ThrowIfNotOutOfRange(TypeIndex, 11);
            Guards.ThrowIfNull(Value, typeof(T11), TypeIndex);
            Guards.ThrowIfTypeMismatch<T11>(TypeIndex, 11, Value, out T11 typedValue);
            return typedValue;
        }
        catch (Exception ex)when (ex is not InvalidAnyStateException)
        {
            // Wrap unexpected exceptions (Better Exception Handling)
            throw new InvalidAnyStateException($"Unexpected error getting value of type {typeof(T11).Name}\nTypeIndex: {TypeIndex}\nValue type: {Value?.GetType().Name ?? "null"}", ex);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT1(out T1? value, out Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 1 && Value is T1 t1)
        {
            value = t1;
            return true;
        }

        if (TypeIndex == 2 && Value is T2 t2)
            remainder = Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t7);
        else if (TypeIndex == 8 && Value is T8 t8)
            remainder = Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t8);
        else if (TypeIndex == 9 && Value is T9 t9)
            remainder = Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t9);
        else if (TypeIndex == 10 && Value is T10 t10)
            remainder = Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t10);
        else if (TypeIndex == 11 && Value is T11 t11)
            remainder = Any<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t11);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT1(out T1? value)
    {
        value = default;
        if (TypeIndex == 1 && Value is T1 t1)
        {
            value = t1;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT2(out T2? value, out Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 2 && Value is T2 t2)
        {
            value = t2;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t1);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t7);
        else if (TypeIndex == 8 && Value is T8 t8)
            remainder = Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t8);
        else if (TypeIndex == 9 && Value is T9 t9)
            remainder = Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t9);
        else if (TypeIndex == 10 && Value is T10 t10)
            remainder = Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t10);
        else if (TypeIndex == 11 && Value is T11 t11)
            remainder = Any<T1, T3, T4, T5, T6, T7, T8, T9, T10, T11>.From(t11);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT2(out T2? value)
    {
        value = default;
        if (TypeIndex == 2 && Value is T2 t2)
        {
            value = t2;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT3(out T3? value, out Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 3 && Value is T3 t3)
        {
            value = t3;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From(t2);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From(t7);
        else if (TypeIndex == 8 && Value is T8 t8)
            remainder = Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From(t8);
        else if (TypeIndex == 9 && Value is T9 t9)
            remainder = Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From(t9);
        else if (TypeIndex == 10 && Value is T10 t10)
            remainder = Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From(t10);
        else if (TypeIndex == 11 && Value is T11 t11)
            remainder = Any<T1, T2, T4, T5, T6, T7, T8, T9, T10, T11>.From(t11);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT3(out T3? value)
    {
        value = default;
        if (TypeIndex == 3 && Value is T3 t3)
        {
            value = t3;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT4(out T4? value, out Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 4 && Value is T4 t4)
        {
            value = t4;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From(t3);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From(t7);
        else if (TypeIndex == 8 && Value is T8 t8)
            remainder = Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From(t8);
        else if (TypeIndex == 9 && Value is T9 t9)
            remainder = Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From(t9);
        else if (TypeIndex == 10 && Value is T10 t10)
            remainder = Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From(t10);
        else if (TypeIndex == 11 && Value is T11 t11)
            remainder = Any<T1, T2, T3, T5, T6, T7, T8, T9, T10, T11>.From(t11);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT4(out T4? value)
    {
        value = default;
        if (TypeIndex == 4 && Value is T4 t4)
        {
            value = t4;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT5(out T5? value, out Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 5 && Value is T5 t5)
        {
            value = t5;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From(t4);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From(t7);
        else if (TypeIndex == 8 && Value is T8 t8)
            remainder = Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From(t8);
        else if (TypeIndex == 9 && Value is T9 t9)
            remainder = Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From(t9);
        else if (TypeIndex == 10 && Value is T10 t10)
            remainder = Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From(t10);
        else if (TypeIndex == 11 && Value is T11 t11)
            remainder = Any<T1, T2, T3, T4, T6, T7, T8, T9, T10, T11>.From(t11);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT5(out T5? value)
    {
        value = default;
        if (TypeIndex == 5 && Value is T5 t5)
        {
            value = t5;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT6(out T6? value, out Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 6 && Value is T6 t6)
        {
            value = t6;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From(t5);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From(t7);
        else if (TypeIndex == 8 && Value is T8 t8)
            remainder = Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From(t8);
        else if (TypeIndex == 9 && Value is T9 t9)
            remainder = Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From(t9);
        else if (TypeIndex == 10 && Value is T10 t10)
            remainder = Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From(t10);
        else if (TypeIndex == 11 && Value is T11 t11)
            remainder = Any<T1, T2, T3, T4, T5, T7, T8, T9, T10, T11>.From(t11);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT6(out T6? value)
    {
        value = default;
        if (TypeIndex == 6 && Value is T6 t6)
        {
            value = t6;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT7(out T7? value, out Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 7 && Value is T7 t7)
        {
            value = t7;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From(t6);
        else if (TypeIndex == 8 && Value is T8 t8)
            remainder = Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From(t8);
        else if (TypeIndex == 9 && Value is T9 t9)
            remainder = Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From(t9);
        else if (TypeIndex == 10 && Value is T10 t10)
            remainder = Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From(t10);
        else if (TypeIndex == 11 && Value is T11 t11)
            remainder = Any<T1, T2, T3, T4, T5, T6, T8, T9, T10, T11>.From(t11);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT7(out T7? value)
    {
        value = default;
        if (TypeIndex == 7 && Value is T7 t7)
        {
            value = t7;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT8(out T8? value, out Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 8 && Value is T8 t8)
        {
            value = t8;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From(t7);
        else if (TypeIndex == 9 && Value is T9 t9)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From(t9);
        else if (TypeIndex == 10 && Value is T10 t10)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From(t10);
        else if (TypeIndex == 11 && Value is T11 t11)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T9, T10, T11>.From(t11);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT8(out T8? value)
    {
        value = default;
        if (TypeIndex == 8 && Value is T8 t8)
        {
            value = t8;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT9(out T9? value, out Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 9 && Value is T9 t9)
        {
            value = t9;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From(t7);
        else if (TypeIndex == 8 && Value is T8 t8)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From(t8);
        else if (TypeIndex == 10 && Value is T10 t10)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From(t10);
        else if (TypeIndex == 11 && Value is T11 t11)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T10, T11>.From(t11);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT9(out T9? value)
    {
        value = default;
        if (TypeIndex == 9 && Value is T9 t9)
        {
            value = t9;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT10(out T10? value, out Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 10 && Value is T10 t10)
        {
            value = t10;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From(t7);
        else if (TypeIndex == 8 && Value is T8 t8)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From(t8);
        else if (TypeIndex == 9 && Value is T9 t9)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From(t9);
        else if (TypeIndex == 11 && Value is T11 t11)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T11>.From(t11);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT10(out T10? value)
    {
        value = default;
        if (TypeIndex == 10 && Value is T10 t10)
        {
            value = t10;
            return true;
        }

        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT11(out T11? value, out Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> remainder)
    {
        value = default;
        remainder = default;
        if (TypeIndex == 11 && Value is T11 t11)
        {
            value = t11;
            return true;
        }

        if (TypeIndex == 1 && Value is T1 t1)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From(t1);
        else if (TypeIndex == 2 && Value is T2 t2)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From(t2);
        else if (TypeIndex == 3 && Value is T3 t3)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From(t3);
        else if (TypeIndex == 4 && Value is T4 t4)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From(t4);
        else if (TypeIndex == 5 && Value is T5 t5)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From(t5);
        else if (TypeIndex == 6 && Value is T6 t6)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From(t6);
        else if (TypeIndex == 7 && Value is T7 t7)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From(t7);
        else if (TypeIndex == 8 && Value is T8 t8)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From(t8);
        else if (TypeIndex == 9 && Value is T9 t9)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From(t9);
        else if (TypeIndex == 10 && Value is T10 t10)
            remainder = Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.From(t10);
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetT11(out T11? value)
    {
        value = default;
        if (TypeIndex == 11 && Value is T11 t11)
        {
            value = t11;
            return true;
        }

        return false;
    }

    /// <summary>
    /// Maps the value contained in this Any to a new type using a common result type.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Map<TResult>(Func<T1, TResult> map1, Func<T2, TResult> map2, Func<T3, TResult> map3, Func<T4, TResult> map4, Func<T5, TResult> map5, Func<T6, TResult> map6, Func<T7, TResult> map7, Func<T8, TResult> map8, Func<T9, TResult> map9, Func<T10, TResult> map10, Func<T11, TResult> map11)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => map1(v1),
            2when Value is T2 v2 => map2(v2),
            3when Value is T3 v3 => map3(v3),
            4when Value is T4 v4 => map4(v4),
            5when Value is T5 v5 => map5(v5),
            6when Value is T6 v6 => map6(v6),
            7when Value is T7 v7 => map7(v7),
            8when Value is T8 v8 => map8(v8),
            9when Value is T9 v9 => map9(v9),
            10when Value is T10 v10 => map10(v10),
            11when Value is T11 v11 => map11(v11),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
    }

    /// <summary>
    /// Maps the value to a new Any type with different type parameters.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Any<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6, TResult7, TResult8, TResult9, TResult10, TResult11> MapAny<TResult1, TResult2, TResult3, TResult4, TResult5, TResult6, TResult7, TResult8, TResult9, TResult10, TResult11>(Func<T1, TResult1> map1, Func<T2, TResult2> map2, Func<T3, TResult3> map3, Func<T4, TResult4> map4, Func<T5, TResult5> map5, Func<T6, TResult6> map6, Func<T7, TResult7> map7, Func<T8, TResult8> map8, Func<T9, TResult9> map9, Func<T10, TResult10> map10, Func<T11, TResult11> map11)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => map1(v1),
            2when Value is T2 v2 => map2(v2),
            3when Value is T3 v3 => map3(v3),
            4when Value is T4 v4 => map4(v4),
            5when Value is T5 v5 => map5(v5),
            6when Value is T6 v6 => map6(v6),
            7when Value is T7 v7 => map7(v7),
            8when Value is T8 v8 => map8(v8),
            9when Value is T9 v9 => map9(v9),
            10when Value is T10 v10 => map10(v10),
            11when Value is T11 v11 => map11(v11),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
    }

    /// <summary>
    /// Maps the value using different strategies for value types and reference types.
    /// </summary>
    public TResult MapValue<TResult>(Func<ValueType, TResult> valueTypeMapper, Func<object, TResult> referenceTypeMapper)
    {
        if (Value is null)
            throw new InvalidAnyStateException("Cannot map null value");
        return _isValueType ? valueTypeMapper(_valueType!) : referenceTypeMapper(_referenceType!);
    }

    /// <summary>
    /// Asynchronously maps the Any value.
    /// </summary>
    public async Task<TResult> MapAsync<TResult>(Func<T1, Task<TResult>> map1, Func<T2, Task<TResult>> map2, Func<T3, Task<TResult>> map3, Func<T4, Task<TResult>> map4, Func<T5, Task<TResult>> map5, Func<T6, Task<TResult>> map6, Func<T7, Task<TResult>> map7, Func<T8, Task<TResult>> map8, Func<T9, Task<TResult>> map9, Func<T10, Task<TResult>> map10, Func<T11, Task<TResult>> map11)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => await map1(v1),
            2when Value is T2 v2 => await map2(v2),
            3when Value is T3 v3 => await map3(v3),
            4when Value is T4 v4 => await map4(v4),
            5when Value is T5 v5 => await map5(v5),
            6when Value is T6 v6 => await map6(v6),
            7when Value is T7 v7 => await map7(v7),
            8when Value is T8 v8 => await map8(v8),
            9when Value is T9 v9 => await map9(v9),
            10when Value is T10 v10 => await map10(v10),
            11when Value is T11 v11 => await map11(v11),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
    }

    /// <summary>
    /// Maps the value with null-safety, returning a default value if null.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult MapOrDefault<TResult>(Func<T1, TResult> map1, Func<T2, TResult> map2, Func<T3, TResult> map3, Func<T4, TResult> map4, Func<T5, TResult> map5, Func<T6, TResult> map6, Func<T7, TResult> map7, Func<T8, TResult> map8, Func<T9, TResult> map9, Func<T10, TResult> map10, Func<T11, TResult> map11, TResult defaultValue = default !)
    {
        if (IsNull)
            return defaultValue;
        return TypeIndex switch
        {
            1when Value is T1 v1 => map1(v1),
            2when Value is T2 v2 => map2(v2),
            3when Value is T3 v3 => map3(v3),
            4when Value is T4 v4 => map4(v4),
            5when Value is T5 v5 => map5(v5),
            6when Value is T6 v6 => map6(v6),
            7when Value is T7 v7 => map7(v7),
            8when Value is T8 v8 => map8(v8),
            9when Value is T9 v9 => map9(v9),
            10when Value is T10 v10 => map10(v10),
            11when Value is T11 v11 => map11(v11),
            _ => defaultValue
        };
    }

    /// <summary>
    /// Maps the value with exception handling.
    /// </summary>
    public TResult MapSafe<TResult>(Func<T1, TResult> map1, Func<T2, TResult> map2, Func<T3, TResult> map3, Func<T4, TResult> map4, Func<T5, TResult> map5, Func<T6, TResult> map6, Func<T7, TResult> map7, Func<T8, TResult> map8, Func<T9, TResult> map9, Func<T10, TResult> map10, Func<T11, TResult> map11, Func<Exception, TResult> errorHandler)
    {
        try
        {
            return TypeIndex switch
            {
                1when Value is T1 v1 => map1(v1),
                2when Value is T2 v2 => map2(v2),
                3when Value is T3 v3 => map3(v3),
                4when Value is T4 v4 => map4(v4),
                5when Value is T5 v5 => map5(v5),
                6when Value is T6 v6 => map6(v6),
                7when Value is T7 v7 => map7(v7),
                8when Value is T8 v8 => map8(v8),
                9when Value is T9 v9 => map9(v9),
                10when Value is T10 v10 => map10(v10),
                11when Value is T11 v11 => map11(v11),
                _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
        }
        catch (Exception ex)
        {
            return errorHandler(ex);
        }
    }

    /// <summary>
    /// Maps the value conditionally based on predicates.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult MapWhere<TResult>(Func<T1, bool> predicate1, Func<T1, TResult> map1, Func<T2, bool> predicate2, Func<T2, TResult> map2, Func<T3, bool> predicate3, Func<T3, TResult> map3, Func<T4, bool> predicate4, Func<T4, TResult> map4, Func<T5, bool> predicate5, Func<T5, TResult> map5, Func<T6, bool> predicate6, Func<T6, TResult> map6, Func<T7, bool> predicate7, Func<T7, TResult> map7, Func<T8, bool> predicate8, Func<T8, TResult> map8, Func<T9, bool> predicate9, Func<T9, TResult> map9, Func<T10, bool> predicate10, Func<T10, TResult> map10, Func<T11, bool> predicate11, Func<T11, TResult> map11, TResult defaultValue = default !)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 && predicate1(v1) => map1(v1),
            2when Value is T2 v2 && predicate2(v2) => map2(v2),
            3when Value is T3 v3 && predicate3(v3) => map3(v3),
            4when Value is T4 v4 && predicate4(v4) => map4(v4),
            5when Value is T5 v5 && predicate5(v5) => map5(v5),
            6when Value is T6 v6 && predicate6(v6) => map6(v6),
            7when Value is T7 v7 && predicate7(v7) => map7(v7),
            8when Value is T8 v8 && predicate8(v8) => map8(v8),
            9when Value is T9 v9 && predicate9(v9) => map9(v9),
            10when Value is T10 v10 && predicate10(v10) => map10(v10),
            11when Value is T11 v11 && predicate11(v11) => map11(v11),
            _ => defaultValue
        };
    }

    /// <summary>
    /// Maps with access to the entire Any instance.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult MapWithContext<TResult>(Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T1, TResult> map1, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T2, TResult> map2, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T3, TResult> map3, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T4, TResult> map4, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T5, TResult> map5, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T6, TResult> map6, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T7, TResult> map7, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T8, TResult> map8, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T9, TResult> map9, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T10, TResult> map10, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T11, TResult> map11)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => map1(this, v1),
            2when Value is T2 v2 => map2(this, v2),
            3when Value is T3 v3 => map3(this, v3),
            4when Value is T4 v4 => map4(this, v4),
            5when Value is T5 v5 => map5(this, v5),
            6when Value is T6 v6 => map6(this, v6),
            7when Value is T7 v7 => map7(this, v7),
            8when Value is T8 v8 => map8(this, v8),
            9when Value is T9 v9 => map9(this, v9),
            10when Value is T10 v10 => map10(this, v10),
            11when Value is T11 v11 => map11(this, v11),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for mapping")};
    }

    /// <summary>
    /// Projects the Any value into a new form using the specified selector functions.
    /// </summary>
    public TResult Select<TResult>(Func<T1, TResult> selector1, Func<T2, TResult> selector2, Func<T3, TResult> selector3, Func<T4, TResult> selector4, Func<T5, TResult> selector5, Func<T6, TResult> selector6, Func<T7, TResult> selector7, Func<T8, TResult> selector8, Func<T9, TResult> selector9, Func<T10, TResult> selector10, Func<T11, TResult> selector11)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => selector1(v1),
            2when Value is T2 v2 => selector2(v2),
            3when Value is T3 v3 => selector3(v3),
            4when Value is T4 v4 => selector4(v4),
            5when Value is T5 v5 => selector5(v5),
            6when Value is T6 v6 => selector6(v6),
            7when Value is T7 v7 => selector7(v7),
            8when Value is T8 v8 => selector8(v8),
            9when Value is T9 v9 => selector9(v9),
            10when Value is T10 v10 => selector10(v10),
            11when Value is T11 v11 => selector11(v11),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for selection")};
    }

    /// <summary>
    /// Projects the Any value using selector functions, or returns a fallback default.
    /// </summary>
    public TResult SelectOrDefault<TResult>(Func<T1, TResult> selector1, Func<T2, TResult> selector2, Func<T3, TResult> selector3, Func<T4, TResult> selector4, Func<T5, TResult> selector5, Func<T6, TResult> selector6, Func<T7, TResult> selector7, Func<T8, TResult> selector8, Func<T9, TResult> selector9, Func<T10, TResult> selector10, Func<T11, TResult> selector11, TResult defaultValue = default !)
    {
        try
        {
            return Select(selector1, selector2, selector3, selector4, selector5, selector6, selector7, selector8, selector9, selector10, selector11);
        }
        catch
        {
            return defaultValue;
        }
    }

    /// <summary>
    /// Attempts to project the Any value using selector functions.
    /// Returns null if uninitialized or type mismatch.
    /// </summary>
    public TResult? TrySelect<TResult>(Func<T1, TResult> selector1, Func<T2, TResult> selector2, Func<T3, TResult> selector3, Func<T4, TResult> selector4, Func<T5, TResult> selector5, Func<T6, TResult> selector6, Func<T7, TResult> selector7, Func<T8, TResult> selector8, Func<T9, TResult> selector9, Func<T10, TResult> selector10, Func<T11, TResult> selector11)
    {
        if (TypeIndex == 0 || Value is null)
            return default;
        return Select(selector1, selector2, selector3, selector4, selector5, selector6, selector7, selector8, selector9, selector10, selector11);
    }

    /// <summary>
    /// Projects the Any value with access to full context.
    /// </summary>
    public TResult SelectWithContext<TResult>(Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T1, TResult> selector1, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T2, TResult> selector2, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T3, TResult> selector3, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T4, TResult> selector4, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T5, TResult> selector5, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T6, TResult> selector6, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T7, TResult> selector7, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T8, TResult> selector8, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T9, TResult> selector9, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T10, TResult> selector10, Func<Any<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>, T11, TResult> selector11)
    {
        return TypeIndex switch
        {
            1when Value is T1 v1 => selector1(this, v1),
            2when Value is T2 v2 => selector2(this, v2),
            3when Value is T3 v3 => selector3(this, v3),
            4when Value is T4 v4 => selector4(this, v4),
            5when Value is T5 v5 => selector5(this, v5),
            6when Value is T6 v6 => selector6(this, v6),
            7when Value is T7 v7 => selector7(this, v7),
            8when Value is T8 v8 => selector8(this, v8),
            9when Value is T9 v9 => selector9(this, v9),
            10when Value is T10 v10 => selector10(this, v10),
            11when Value is T11 v11 => selector11(this, v11),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for selection")};
    }

    /// <summary>
    /// Conditionally maps Any value if predicate passes, otherwise returns default.
    /// </summary>
    public TResult SelectWhere<TResult>(Func<T1, bool> predicate1, Func<T1, TResult> selector1, Func<T2, bool> predicate2, Func<T2, TResult> selector2, Func<T3, bool> predicate3, Func<T3, TResult> selector3, Func<T4, bool> predicate4, Func<T4, TResult> selector4, Func<T5, bool> predicate5, Func<T5, TResult> selector5, Func<T6, bool> predicate6, Func<T6, TResult> selector6, Func<T7, bool> predicate7, Func<T7, TResult> selector7, Func<T8, bool> predicate8, Func<T8, TResult> selector8, Func<T9, bool> predicate9, Func<T9, TResult> selector9, Func<T10, bool> predicate10, Func<T10, TResult> selector10, Func<T11, bool> predicate11, Func<T11, TResult> selector11, TResult defaultValue = default !)
    {
        if (TypeIndex == 1 && Value is T1 v1 && predicate1(v1))
            return selector1(v1);
        else if (TypeIndex == 2 && Value is T2 v2 && predicate2(v2))
            return selector2(v2);
        else if (TypeIndex == 3 && Value is T3 v3 && predicate3(v3))
            return selector3(v3);
        else if (TypeIndex == 4 && Value is T4 v4 && predicate4(v4))
            return selector4(v4);
        else if (TypeIndex == 5 && Value is T5 v5 && predicate5(v5))
            return selector5(v5);
        else if (TypeIndex == 6 && Value is T6 v6 && predicate6(v6))
            return selector6(v6);
        else if (TypeIndex == 7 && Value is T7 v7 && predicate7(v7))
            return selector7(v7);
        else if (TypeIndex == 8 && Value is T8 v8 && predicate8(v8))
            return selector8(v8);
        else if (TypeIndex == 9 && Value is T9 v9 && predicate9(v9))
            return selector9(v9);
        else if (TypeIndex == 10 && Value is T10 v10 && predicate10(v10))
            return selector10(v10);
        else if (TypeIndex == 11 && Value is T11 v11 && predicate11(v11))
            return selector11(v11);
        else
            return defaultValue;
    }

    /// <summary>
    /// Asynchronously projects the Any value using the specified async selector functions.
    /// </summary>
    public async Task<TResult> SelectAsync<TResult>(Func<T1, Task<TResult>> selector1, Func<T2, Task<TResult>> selector2, Func<T3, Task<TResult>> selector3, Func<T4, Task<TResult>> selector4, Func<T5, Task<TResult>> selector5, Func<T6, Task<TResult>> selector6, Func<T7, Task<TResult>> selector7, Func<T8, Task<TResult>> selector8, Func<T9, Task<TResult>> selector9, Func<T10, Task<TResult>> selector10, Func<T11, Task<TResult>> selector11)
    {
        return await (TypeIndex switch
        {
            1when Value is T1 v1 => selector1(v1),
            2when Value is T2 v2 => selector2(v2),
            3when Value is T3 v3 => selector3(v3),
            4when Value is T4 v4 => selector4(v4),
            5when Value is T5 v5 => selector5(v5),
            6when Value is T6 v6 => selector6(v6),
            7when Value is T7 v7 => selector7(v7),
            8when Value is T8 v8 => selector8(v8),
            9when Value is T9 v9 => selector9(v9),
            10when Value is T10 v10 => selector10(v10),
            11when Value is T11 v11 => selector11(v11),
            _ => throw new InvalidAnyStateException("Any is not in a valid state for selection")});
    }

    /// <summary>
    /// Asynchronously projects the Any value, or returns fallback default.
    /// </summary>
    public async Task<TResult> SelectAsyncOrDefault<TResult>(Func<T1, Task<TResult>> selector1, Func<T2, Task<TResult>> selector2, Func<T3, Task<TResult>> selector3, Func<T4, Task<TResult>> selector4, Func<T5, Task<TResult>> selector5, Func<T6, Task<TResult>> selector6, Func<T7, Task<TResult>> selector7, Func<T8, Task<TResult>> selector8, Func<T9, Task<TResult>> selector9, Func<T10, Task<TResult>> selector10, Func<T11, Task<TResult>> selector11, TResult defaultValue = default !)
    {
        try
        {
            return await SelectAsync(selector1, selector2, selector3, selector4, selector5, selector6, selector7, selector8, selector9, selector10, selector11);
        }
        catch
        {
            return defaultValue;
        }
    }

    /// <summary>
    /// Executes the appropriate action based on the Any type.
    /// </summary>
    public void Switch(Action<T1> case1, Action<T2> case2, Action<T3> case3, Action<T4> case4, Action<T5> case5, Action<T6> case6, Action<T7> case7, Action<T8> case8, Action<T9> case9, Action<T10> case10, Action<T11> case11)
    {
        switch (TypeIndex)
        {
            case 1when Value is T1 v1:
                case1(v1);
                break;
            case 2when Value is T2 v2:
                case2(v2);
                break;
            case 3when Value is T3 v3:
                case3(v3);
                break;
            case 4when Value is T4 v4:
                case4(v4);
                break;
            case 5when Value is T5 v5:
                case5(v5);
                break;
            case 6when Value is T6 v6:
                case6(v6);
                break;
            case 7when Value is T7 v7:
                case7(v7);
                break;
            case 8when Value is T8 v8:
                case8(v8);
                break;
            case 9when Value is T9 v9:
                case9(v9);
                break;
            case 10when Value is T10 v10:
                case10(v10);
                break;
            case 11when Value is T11 v11:
                case11(v11);
                break;
            default:
                throw new InvalidAnyStateException("Any is not in a valid state for switching");
        };
    }

    /// <summary>
    /// Asynchronously executes the appropriate action based on the Any type.
    /// </summary>
    public async Task SwitchAsync(Func<T1, Task> case1, Func<T2, Task> case2, Func<T3, Task> case3, Func<T4, Task> case4, Func<T5, Task> case5, Func<T6, Task> case6, Func<T7, Task> case7, Func<T8, Task> case8, Func<T9, Task> case9, Func<T10, Task> case10, Func<T11, Task> case11)
    {
        switch (TypeIndex)
        {
            case 1when Value is T1 v1:
                await case1(v1);
                break;
            case 2when Value is T2 v2:
                await case2(v2);
                break;
            case 3when Value is T3 v3:
                await case3(v3);
                break;
            case 4when Value is T4 v4:
                await case4(v4);
                break;
            case 5when Value is T5 v5:
                await case5(v5);
                break;
            case 6when Value is T6 v6:
                await case6(v6);
                break;
            case 7when Value is T7 v7:
                await case7(v7);
                break;
            case 8when Value is T8 v8:
                await case8(v8);
                break;
            case 9when Value is T9 v9:
                await case9(v9);
                break;
            case 10when Value is T10 v10:
                await case10(v10);
                break;
            case 11when Value is T11 v11:
                await case11(v11);
                break;
            default:
                throw new InvalidAnyStateException("Any is not in a valid state for switching");
        }
    }

    /// <summary>
    /// Executes the appropriate action if the Any is initialized; otherwise, runs default fallback.
    /// </summary>
    public void SwitchOrDefault(Action<T1> case1, Action<T2> case2, Action<T3> case3, Action<T4> case4, Action<T5> case5, Action<T6> case6, Action<T7> case7, Action<T8> case8, Action<T9> case9, Action<T10> case10, Action<T11> case11, Action fallback)
    {
        switch (TypeIndex)
        {
            case 1when Value is T1 v1:
                case1(v1);
                break;
            case 2when Value is T2 v2:
                case2(v2);
                break;
            case 3when Value is T3 v3:
                case3(v3);
                break;
            case 4when Value is T4 v4:
                case4(v4);
                break;
            case 5when Value is T5 v5:
                case5(v5);
                break;
            case 6when Value is T6 v6:
                case6(v6);
                break;
            case 7when Value is T7 v7:
                case7(v7);
                break;
            case 8when Value is T8 v8:
                case8(v8);
                break;
            case 9when Value is T9 v9:
                case9(v9);
                break;
            case 10when Value is T10 v10:
                case10(v10);
                break;
            case 11when Value is T11 v11:
                case11(v11);
                break;
            default:
                fallback();
                break;
        }
    }

    /// <summary>
    /// Deconstructs the Any into individual out variables based on the active type.
    /// </summary>
    public void Deconstruct(out T1 value1, out T2 value2, out T3 value3, out T4 value4, out T5 value5, out T6 value6, out T7 value7, out T8 value8, out T9 value9, out T10 value10, out T11 value11)
    {
        value1 = default !;
        value2 = default !;
        value3 = default !;
        value4 = default !;
        value5 = default !;
        value6 = default !;
        value7 = default !;
        value8 = default !;
        value9 = default !;
        value10 = default !;
        value11 = default !;
        switch (TypeIndex)
        {
            case 1when Value is T1 v1:
                value1 = v1;
                break;
            case 2when Value is T2 v2:
                value2 = v2;
                break;
            case 3when Value is T3 v3:
                value3 = v3;
                break;
            case 4when Value is T4 v4:
                value4 = v4;
                break;
            case 5when Value is T5 v5:
                value5 = v5;
                break;
            case 6when Value is T6 v6:
                value6 = v6;
                break;
            case 7when Value is T7 v7:
                value7 = v7;
                break;
            case 8when Value is T8 v8:
                value8 = v8;
                break;
            case 9when Value is T9 v9:
                value9 = v9;
                break;
            case 10when Value is T10 v10:
                value10 = v10;
                break;
            case 11when Value is T11 v11:
                value11 = v11;
                break;
            default:
                throw new InvalidAnyStateException($"""
                Unable to deconstruct Any — invalid TypeIndex ({TypeIndex}) or type mismatch.
                Actual value: {Value?.GetType().Name ?? "null"}
            """);
        }
    }
}