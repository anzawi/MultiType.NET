namespace MultiType.NET.SourceGenerator;

using System;
using System.IO;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

internal static class AnyEmitter
{
    private const string GeneratedCodeHeader = """
                                               //------------------------------------------------------------------------------
                                               // <auto-generated>
                                               //     This code was generated by MultiType.NET.SourceGenerator
                                               //     Library Version: {LibraryVersion}
                                               //     Runtime Version: {RuntimeVersion}
                                               //     Generated: {GenerationTime}
                                               //
                                               //     Changes to this file may cause incorrect behavior and will be lost if
                                               //     the code is regenerated.
                                               // </auto-generated>
                                               //------------------------------------------------------------------------------

                                               """;

    private const string AnyNamespace = "MultiType.NET.Core.Anys.Generated";
    private const string AnyJsonConverterNamespace = "MultiType.NET.Core.Serialization.Generated";

    private static readonly string OutputPath = Path.Combine(
        AppDomain.CurrentDomain.BaseDirectory,
        "..", // go up to bin
        "..", // go up to Debug/Release
        "..", // go up to project root
        "..", // go up to solution
        "MultiType.NET.Core",
        "Anys",
        "Generated"
    );

    private static readonly string OutputSerializationPath = Path.Combine(
        AppDomain.CurrentDomain.BaseDirectory,
        "..", // go up to bin
        "..", // go up to Debug/Release
        "..", // go up to project root
        "..", // go up to solution
        "MultiType.NET.Core",
        "AnySerializations",
        "Generated"
    );

    private const int MinArity = 2;

    public static void EmitAnyTypes(int maxArity, string outputPath, bool initial)
    {
        var anyOutputPath = initial ? OutputPath : Path.Combine(outputPath, "Any");
        var anySerializationOutputPath = initial ? OutputSerializationPath :  Path.Combine(outputPath, "Serialization");
        Directory.CreateDirectory(anyOutputPath);
        Directory.CreateDirectory(anySerializationOutputPath);

        for (var arity = MinArity; arity <= maxArity; arity++)
        {
            if (!initial && arity < 17)
            {
                // skip generating < 17
                continue;
            }
            
            Console.WriteLine($"Generating Any type for arity {arity}...");
            var typeContent = new AnyTypeBuilder(arity, AnyNamespace)
                .AddCoreStructure()
                .AddEqualityMembers()
                .AddMatchMethods()
                .AddTryMatchMethods()
                .AddGetMethods()
                .AddTryGetMethods()
                .AddMapMethods()
                .AddSelectMethods()
                .AddSwitchMethods()
                .AddDeconstructMethod().
                AddTryParseAndCastMethods()
                .Build();

            var formattedTypeContent = FormattedContent(typeContent);


            Console.WriteLine($"Writing Any type for arity {arity}...");
            File.WriteAllText(
                Path.Combine(anyOutputPath, $"Any{arity}.g.cs"),
                formattedTypeContent);

            Console.WriteLine($"'Any{arity}.g.cs' Generated");
        }

        for (var arity = MinArity; arity <= maxArity; arity++)
        {
            Console.WriteLine($"Generating Any type json serialization converter for arity {arity}...");
            var convertorContent = new AnyJsonConverterBuilder(arity, AnyNamespace, AnyJsonConverterNamespace)
                .AddHeaders()
                .AddReadMethod()
                .AddWriteMethod()
                .Build();

            var formattedConvertorContent = FormattedContent(convertorContent);

            Console.WriteLine($"Writing Any type json converter for arity {arity}...");
            File.WriteAllText(
                Path.Combine(anySerializationOutputPath, $"Any{arity}JsonConverter.g.cs"),
                formattedConvertorContent);

            Console.WriteLine($"'Any{arity}JsonConverter.g.cs' Generated");
        }

        // No need for the factory anymore!
        /*// generate AnyJsonConverterFactory
        if (initial)
        {
            Console.WriteLine($"Writing Any type JSON converter factory for arity {maxArity} and above...");
            var convertorFactoryContent = new AnyJsonConvertorFactoryBuilder(maxArity)
                .AddConvertorFactory()
                .Build();
            var formattedConvertorFactoryContent = FormattedContent(convertorFactoryContent);
            File.WriteAllText(
                Path.Combine(anySerializationOutputPath, $"AnyJsonConverterFactory.g.cs"),
                formattedConvertorFactoryContent);
            Console.WriteLine("'AnyJsonConverterFactory.g.cs' Generated");
        }
        else
        {
            Console.WriteLine($"Skip JSON converter factory!. already generated.");
        }*/
    }

    private static string FormattedContent(string? content)
    {
        // Add nullable enable directive and format the code
        var formattedContent = FormatCode($$"""
                                            {{GetGeneratedCodeHeader()}}

                                            #nullable enable

                                            {{content}}
                                            """);
        return formattedContent;
    }

    private static string FormatCode(string sourceCode)
    {
        var tree = CSharpSyntaxTree.ParseText(sourceCode);
        var root = tree.GetRoot();
        var formatted = root.NormalizeWhitespace();
        return formatted.ToFullString();
    }

    private static string GetGeneratedCodeHeader()
    {
        var runtimeVersion = Environment.Version.ToString();
        var generationTime = DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss");
        var libraryVersion = typeof(AnyEmitter).Assembly.GetName().Version?.ToString() ?? "0.0.0";

        return GeneratedCodeHeader
            .Replace("{LibraryVersion}", libraryVersion)
            .Replace("{RuntimeVersion}", runtimeVersion)
            .Replace("{GenerationTime}", generationTime + " UTC");
    }
}